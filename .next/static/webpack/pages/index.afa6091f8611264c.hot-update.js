"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./lib/api.js":
/*!********************!*\
  !*** ./lib/api.js ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n// Define API base URL\n// In a real app, this would be read from environment variables\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000\";\n// Create axios instance with default config\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    // Add longer timeout to handle potential network delays\n    timeout: 15000\n});\n// Add request interceptor to attach auth token\napiClient.interceptors.request.use((config)=>{\n    // Skip authentication for local development if needed\n    if (true) {\n        const token = localStorage.getItem(\"auth_token\");\n        if (token) {\n            config.headers[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n    }\n    console.log(\"Making request to: \".concat(config.baseURL).concat(config.url));\n    return config;\n}, (error)=>Promise.reject(error));\n// Add response interceptor for better error handling\napiClient.interceptors.response.use((response)=>response, (error)=>{\n    // Log better error information\n    if (error.response) {\n        var _error_config;\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        console.error(\"API Error Response:\", {\n            data: error.response.data,\n            status: error.response.status,\n            headers: error.response.headers,\n            url: (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url\n        });\n    } else if (error.request) {\n        var _error_config1, _error_config2;\n        // The request was made but no response was received\n        console.error(\"API No Response:\", {\n            request: error.request,\n            message: \"No response received from server. Is the backend running?\",\n            url: (_error_config1 = error.config) === null || _error_config1 === void 0 ? void 0 : _error_config1.url,\n            baseURL: (_error_config2 = error.config) === null || _error_config2 === void 0 ? void 0 : _error_config2.baseURL\n        });\n        console.log(\"Backend connectivity issue. Make sure Django server is running at:\", API_BASE_URL);\n    } else {\n        // Something happened in setting up the request that triggered an Error\n        console.error(\"API Request Error:\", error.message);\n    }\n    return Promise.reject(error);\n});\n// Helper function for retry logic\nconst apiCallWithRetry = async function(apiCall) {\n    let retryCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, initialDelayMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1000;\n    let lastError;\n    for(let attempt = 0; attempt < retryCount; attempt++){\n        try {\n            return await apiCall();\n        } catch (error) {\n            lastError = error;\n            // Only retry network or timeout errors\n            if (!error.code || error.code !== \"ERR_NETWORK\" && error.code !== \"ECONNABORTED\") {\n                throw error;\n            }\n            const delayMs = initialDelayMs * Math.pow(2, attempt);\n            console.log(\"Attempt \".concat(attempt + 1, \" failed, retrying in \").concat(delayMs, \"ms...\"));\n            await new Promise((resolve)=>setTimeout(resolve, delayMs));\n        }\n    }\n    throw lastError;\n};\n// Define API endpoints\nconst api = {\n    // Check API connectivity (new method)\n    checkBackendConnection: async ()=>{\n        try {\n            // Simple endpoint that should always be available\n            const response = await apiClient.get(\"/api/\");\n            console.log(\"Backend connection successful\");\n            return true;\n        } catch (error) {\n            console.error(\"Backend connection failed:\", error.message);\n            return false;\n        }\n    },\n    // Auth (Note: Your actual backend may have different auth endpoints)\n    login: async (credentials)=>{\n        try {\n            // This endpoint might need to be updated based on your actual backend auth endpoints\n            const response = await apiCallWithRetry(()=>apiClient.post(\"/api/token/\", credentials));\n            return response.data;\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        }\n    },\n    // Departments\n    getDepartments: async ()=>{\n        try {\n            console.log(\"Fetching departments from:\", \"\".concat(API_BASE_URL, \"/api/departments/\"));\n            const response = await apiCallWithRetry(()=>apiClient.get(\"/api/departments/\"));\n            console.log(\"Departments fetched successfully:\", response.data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching departments:\", error);\n            throw error;\n        }\n    },\n    // Business Units\n    getBusinessUnits: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/business-units/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business units:\", error);\n            throw error;\n        }\n    },\n    getBusinessUnit: async (businessUnitId)=>{\n        try {\n            const response = await apiClient.get(\"/api/business-units/\".concat(businessUnitId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    createBusinessUnit: async (businessUnitData)=>{\n        try {\n            const response = await apiClient.post(\"/api/business-units/\", businessUnitData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating business unit:\", error);\n            throw error;\n        }\n    },\n    updateBusinessUnit: async (businessUnitId, businessUnitData)=>{\n        try {\n            const response = await apiClient.put(\"/api/business-units/\".concat(businessUnitId, \"/\"), businessUnitData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteBusinessUnit: async (businessUnitId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/business-units/\".concat(businessUnitId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKR Business Units\n    getOKRBusinessUnits: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/business_units/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business units for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    assignBusinessUnitsToOKR: async (okrId, businessUnitIds)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/assign_business_units/\"), businessUnitIds);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error assigning business units to OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Users\n    getUsers: async ()=>{\n        try {\n            console.log(\"Fetching users from:\", \"\".concat(API_BASE_URL, \"/api/users/\"));\n            const response = await apiCallWithRetry(()=>apiClient.get(\"/api/users/\"));\n            console.log(\"Users fetched successfully:\", response.data);\n            // Return empty array if the data is null or undefined\n            return response.data || [];\n        } catch (error) {\n            console.error(\"Error fetching users:\", error);\n            // Return empty array on error to prevent UI breaking\n            return [];\n        }\n    },\n    getUser: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/users/\".concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKRs\n    getOKRs: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKRs:\", error);\n            throw error;\n        }\n    },\n    getOKR: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    createOKR: async (okrData)=>{\n        try {\n            // Handle the multi-user assignment and business units in the backend\n            const response = await apiClient.post(\"/api/okrs/\", okrData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating OKR:\", error);\n            throw error;\n        }\n    },\n    updateOKR: async (okrId, okrData)=>{\n        try {\n            var _okrData_assigned_users_find;\n            // Transform the data format to match what the backend expects\n            const transformedData = {\n                ...okrData,\n                // For user mappings - convert assigned_users to the format backend expects\n                assigned_user_ids: okrData.assigned_users ? okrData.assigned_users.map((user)=>user.user_id) : [],\n                // Set primary user\n                primary_user_id: okrData.assigned_users ? (_okrData_assigned_users_find = okrData.assigned_users.find((user)=>user.is_primary)) === null || _okrData_assigned_users_find === void 0 ? void 0 : _okrData_assigned_users_find.user_id : null,\n                // Use business_unit_ids if it exists, otherwise use business_units\n                business_unit_ids: okrData.business_unit_ids || okrData.business_units || []\n            };\n            // Remove fields the backend doesn't expect\n            if (transformedData.assigned_users) {\n                delete transformedData.assigned_users;\n            }\n            if (transformedData.business_units && transformedData.business_unit_ids) {\n                delete transformedData.business_units;\n            }\n            // Log the transformed data being sent\n            console.log(\"Data being sent to update OKR API:\", {\n                endpoint: \"/api/okrs/\".concat(okrId, \"/\"),\n                original: okrData,\n                transformed: transformedData\n            });\n            // Send the request\n            const response = await apiClient.put(\"/api/okrs/\".concat(okrId, \"/\"), transformedData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteOKR: async (okrId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/okrs/\".concat(okrId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Child OKRs - Get OKRs with a specific parent_okr\n    getChildOKRs: async (parentOkrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/?parent_okr=\".concat(parentOkrId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching child OKRs for parent \".concat(parentOkrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Get assigned users for an OKR\n    getOKRAssignedUsers: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/assigned_users/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching assigned users for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Add a user to an OKR \n    addUserToOKR: async (okrId, userData)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/assign_user/\"), userData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error adding user to OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Remove a user from an OKR\n    removeUserFromOKR: async (okrId, userId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/okrs/\".concat(okrId, \"/remove_user/\").concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error removing user from OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Set a user as primary for an OKR\n    setPrimaryUserForOKR: async (okrId, userId)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/set_primary_user/\"), {\n                user_id: userId\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error setting primary user for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Tasks\n    getTasks: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks:\", error);\n            throw error;\n        }\n    },\n    getTask: async (taskId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/\".concat(taskId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    createTask: async (taskData)=>{\n        try {\n            const response = await apiClient.post(\"/api/tasks/\", taskData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating task:\", error);\n            throw error;\n        }\n    },\n    updateTask: async (taskId, taskData)=>{\n        try {\n            const response = await apiClient.put(\"/api/tasks/\".concat(taskId, \"/\"), taskData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteTask: async (taskId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/tasks/\".concat(taskId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKR Tasks - Get tasks for a specific OKR\n    getOKRTasks: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/?linked_to_okr=\".concat(okrId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // User-specific OKRs - now supports both assigned_to (legacy) and okr_user_mappings\n    getUserOKRs: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/user/\".concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKRs for user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // User-specific tasks\n    getUserTasks: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/?assigned_to=\".concat(userId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks for user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // TaskChallenges\n    getTaskChallenges: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task challenges:\", error);\n            throw error;\n        }\n    },\n    getTaskChallenge: async (challengeId)=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/\".concat(challengeId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    createTaskChallenge: async (challengeData)=>{\n        try {\n            const response = await apiClient.post(\"/api/task-challenges/\", challengeData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating task challenge:\", error);\n            throw error;\n        }\n    },\n    updateTaskChallenge: async (challengeId, challengeData)=>{\n        try {\n            const response = await apiClient.put(\"/api/task-challenges/\".concat(challengeId, \"/\"), challengeData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteTaskChallenge: async (challengeId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/task-challenges/\".concat(challengeId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    // Get challenges for a specific task\n    getTaskChallengesByTask: async (taskId)=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/by_task/?task_id=\".concat(taskId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching challenges for task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDOUIsSUFBSTtZQUNGLE1BQU1wRSxXQUFXLE1BQU1sQixVQUFVb0MsR0FBRyxDQUFDLHlDQUFnRCxPQUFQa0Q7WUFDOUUsT0FBT3BFLFNBQVNDLElBQUk7UUFDdEIsRUFBRSxPQUFPSixPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQyxzQ0FBNkMsT0FBUHVFLFFBQU8sTUFBSXZFO1lBQy9ELE1BQU1BO1FBQ1I7SUFDRjtBQUNGO0FBRUEsK0RBQWVtQixHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGkuanM/NDU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5cclxuLy8gRGVmaW5lIEFQSSBiYXNlIFVSTFxyXG4vLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIHJlYWQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcclxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJztcclxuXHJcbi8vIENyZWF0ZSBheGlvcyBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgY29uZmlnXHJcbmNvbnN0IGFwaUNsaWVudCA9IGF4aW9zLmNyZWF0ZSh7XHJcbiAgYmFzZVVSTDogQVBJX0JBU0VfVVJMLFxyXG4gIGhlYWRlcnM6IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgfSxcclxuICAvLyBBZGQgbG9uZ2VyIHRpbWVvdXQgdG8gaGFuZGxlIHBvdGVudGlhbCBuZXR3b3JrIGRlbGF5c1xyXG4gIHRpbWVvdXQ6IDE1MDAwLFxyXG59KTtcclxuXHJcbi8vIEFkZCByZXF1ZXN0IGludGVyY2VwdG9yIHRvIGF0dGFjaCBhdXRoIHRva2VuXHJcbmFwaUNsaWVudC5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXHJcbiAgKGNvbmZpZykgPT4ge1xyXG4gICAgLy8gU2tpcCBhdXRoZW50aWNhdGlvbiBmb3IgbG9jYWwgZGV2ZWxvcG1lbnQgaWYgbmVlZGVkXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aF90b2tlbicpO1xyXG4gICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICBjb25maWcuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKGBNYWtpbmcgcmVxdWVzdCB0bzogJHtjb25maWcuYmFzZVVSTH0ke2NvbmZpZy51cmx9YCk7XHJcbiAgICByZXR1cm4gY29uZmlnO1xyXG4gIH0sXHJcbiAgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcilcclxuKTtcclxuXHJcbi8vIEFkZCByZXNwb25zZSBpbnRlcmNlcHRvciBmb3IgYmV0dGVyIGVycm9yIGhhbmRsaW5nXHJcbmFwaUNsaWVudC5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKFxyXG4gIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsXHJcbiAgKGVycm9yKSA9PiB7XHJcbiAgICAvLyBMb2cgYmV0dGVyIGVycm9yIGluZm9ybWF0aW9uXHJcbiAgICBpZiAoZXJyb3IucmVzcG9uc2UpIHtcclxuICAgICAgLy8gVGhlIHJlcXVlc3Qgd2FzIG1hZGUgYW5kIHRoZSBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYSBzdGF0dXMgY29kZVxyXG4gICAgICAvLyB0aGF0IGZhbGxzIG91dCBvZiB0aGUgcmFuZ2Ugb2YgMnh4XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvciBSZXNwb25zZTonLCB7XHJcbiAgICAgICAgZGF0YTogZXJyb3IucmVzcG9uc2UuZGF0YSxcclxuICAgICAgICBzdGF0dXM6IGVycm9yLnJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICBoZWFkZXJzOiBlcnJvci5yZXNwb25zZS5oZWFkZXJzLFxyXG4gICAgICAgIHVybDogZXJyb3IuY29uZmlnPy51cmwsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChlcnJvci5yZXF1ZXN0KSB7XHJcbiAgICAgIC8vIFRoZSByZXF1ZXN0IHdhcyBtYWRlIGJ1dCBubyByZXNwb25zZSB3YXMgcmVjZWl2ZWRcclxuICAgICAgY29uc29sZS5lcnJvcignQVBJIE5vIFJlc3BvbnNlOicsIHtcclxuICAgICAgICByZXF1ZXN0OiBlcnJvci5yZXF1ZXN0LFxyXG4gICAgICAgIG1lc3NhZ2U6ICdObyByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlci4gSXMgdGhlIGJhY2tlbmQgcnVubmluZz8nLFxyXG4gICAgICAgIHVybDogZXJyb3IuY29uZmlnPy51cmwsXHJcbiAgICAgICAgYmFzZVVSTDogZXJyb3IuY29uZmlnPy5iYXNlVVJMLFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc29sZS5sb2coJ0JhY2tlbmQgY29ubmVjdGl2aXR5IGlzc3VlLiBNYWtlIHN1cmUgRGphbmdvIHNlcnZlciBpcyBydW5uaW5nIGF0OicsIEFQSV9CQVNFX1VSTCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTb21ldGhpbmcgaGFwcGVuZWQgaW4gc2V0dGluZyB1cCB0aGUgcmVxdWVzdCB0aGF0IHRyaWdnZXJlZCBhbiBFcnJvclxyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgUmVxdWVzdCBFcnJvcjonLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgfVxyXG4pO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciByZXRyeSBsb2dpY1xyXG5jb25zdCBhcGlDYWxsV2l0aFJldHJ5ID0gYXN5bmMgKGFwaUNhbGwsIHJldHJ5Q291bnQgPSAzLCBpbml0aWFsRGVsYXlNcyA9IDEwMDApID0+IHtcclxuICBsZXQgbGFzdEVycm9yO1xyXG4gIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgcmV0cnlDb3VudDsgYXR0ZW1wdCsrKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gYXdhaXQgYXBpQ2FsbCgpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbGFzdEVycm9yID0gZXJyb3I7XHJcbiAgICAgIC8vIE9ubHkgcmV0cnkgbmV0d29yayBvciB0aW1lb3V0IGVycm9yc1xyXG4gICAgICBpZiAoIWVycm9yLmNvZGUgfHwgKGVycm9yLmNvZGUgIT09ICdFUlJfTkVUV09SSycgJiYgZXJyb3IuY29kZSAhPT0gJ0VDT05OQUJPUlRFRCcpKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGRlbGF5TXMgPSBpbml0aWFsRGVsYXlNcyAqIE1hdGgucG93KDIsIGF0dGVtcHQpO1xyXG4gICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdCAke2F0dGVtcHQgKyAxfSBmYWlsZWQsIHJldHJ5aW5nIGluICR7ZGVsYXlNc31tcy4uLmApO1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlNcykpO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aHJvdyBsYXN0RXJyb3I7XHJcbn07XHJcblxyXG4vLyBEZWZpbmUgQVBJIGVuZHBvaW50c1xyXG5jb25zdCBhcGkgPSB7XHJcbiAgLy8gQ2hlY2sgQVBJIGNvbm5lY3Rpdml0eSAobmV3IG1ldGhvZClcclxuICBjaGVja0JhY2tlbmRDb25uZWN0aW9uOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTaW1wbGUgZW5kcG9pbnQgdGhhdCBzaG91bGQgYWx3YXlzIGJlIGF2YWlsYWJsZVxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvJyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdCYWNrZW5kIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bCcpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0JhY2tlbmQgY29ubmVjdGlvbiBmYWlsZWQ6JywgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIEF1dGggKE5vdGU6IFlvdXIgYWN0dWFsIGJhY2tlbmQgbWF5IGhhdmUgZGlmZmVyZW50IGF1dGggZW5kcG9pbnRzKVxyXG4gIGxvZ2luOiBhc3luYyAoY3JlZGVudGlhbHMpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRoaXMgZW5kcG9pbnQgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIHlvdXIgYWN0dWFsIGJhY2tlbmQgYXV0aCBlbmRwb2ludHNcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsV2l0aFJldHJ5KCgpID0+IGFwaUNsaWVudC5wb3N0KCcvYXBpL3Rva2VuLycsIGNyZWRlbnRpYWxzKSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTG9naW4gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIERlcGFydG1lbnRzXHJcbiAgZ2V0RGVwYXJ0bWVudHM6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBkZXBhcnRtZW50cyBmcm9tOicsIGAke0FQSV9CQVNFX1VSTH0vYXBpL2RlcGFydG1lbnRzL2ApO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNhbGxXaXRoUmV0cnkoKCkgPT4gYXBpQ2xpZW50LmdldCgnL2FwaS9kZXBhcnRtZW50cy8nKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdEZXBhcnRtZW50cyBmZXRjaGVkIHN1Y2Nlc3NmdWxseTonLCByZXNwb25zZS5kYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBkZXBhcnRtZW50czonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gQnVzaW5lc3MgVW5pdHNcclxuICBnZXRCdXNpbmVzc1VuaXRzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvYnVzaW5lc3MtdW5pdHMvJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYnVzaW5lc3MgdW5pdHM6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGdldEJ1c2luZXNzVW5pdDogYXN5bmMgKGJ1c2luZXNzVW5pdElkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvYnVzaW5lc3MtdW5pdHMvJHtidXNpbmVzc1VuaXRJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgYnVzaW5lc3MgdW5pdCAke2J1c2luZXNzVW5pdElkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgY3JlYXRlQnVzaW5lc3NVbml0OiBhc3luYyAoYnVzaW5lc3NVbml0RGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS9idXNpbmVzcy11bml0cy8nLCBidXNpbmVzc1VuaXREYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBidXNpbmVzcyB1bml0OicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICB1cGRhdGVCdXNpbmVzc1VuaXQ6IGFzeW5jIChidXNpbmVzc1VuaXRJZCwgYnVzaW5lc3NVbml0RGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucHV0KGAvYXBpL2J1c2luZXNzLXVuaXRzLyR7YnVzaW5lc3NVbml0SWR9L2AsIGJ1c2luZXNzVW5pdERhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIGJ1c2luZXNzIHVuaXQgJHtidXNpbmVzc1VuaXRJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGRlbGV0ZUJ1c2luZXNzVW5pdDogYXN5bmMgKGJ1c2luZXNzVW5pdElkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvYnVzaW5lc3MtdW5pdHMvJHtidXNpbmVzc1VuaXRJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgYnVzaW5lc3MgdW5pdCAke2J1c2luZXNzVW5pdElkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gT0tSIEJ1c2luZXNzIFVuaXRzXHJcbiAgZ2V0T0tSQnVzaW5lc3NVbml0czogYXN5bmMgKG9rcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvb2tycy8ke29rcklkfS9idXNpbmVzc191bml0cy9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBidXNpbmVzcyB1bml0cyBmb3IgT0tSICR7b2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBhc3NpZ25CdXNpbmVzc1VuaXRzVG9PS1I6IGFzeW5jIChva3JJZCwgYnVzaW5lc3NVbml0SWRzKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvYXBpL29rcnMvJHtva3JJZH0vYXNzaWduX2J1c2luZXNzX3VuaXRzL2AsIGJ1c2luZXNzVW5pdElkcyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYXNzaWduaW5nIGJ1c2luZXNzIHVuaXRzIHRvIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVXNlcnNcclxuICBnZXRVc2VyczogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHVzZXJzIGZyb206JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvdXNlcnMvYCk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeSgoKSA9PiBhcGlDbGllbnQuZ2V0KCcvYXBpL3VzZXJzLycpKTtcclxuICAgICAgY29uc29sZS5sb2coJ1VzZXJzIGZldGNoZWQgc3VjY2Vzc2Z1bGx5OicsIHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaWYgdGhlIGRhdGEgaXMgbnVsbCBvciB1bmRlZmluZWRcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB1c2VyczonLCBlcnJvcik7XHJcbiAgICAgIC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvciB0byBwcmV2ZW50IFVJIGJyZWFraW5nXHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGdldFVzZXI6IGFzeW5jICh1c2VySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS91c2Vycy8ke3VzZXJJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgdXNlciAke3VzZXJJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIE9LUnNcclxuICBnZXRPS1JzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvb2tycy8nKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBPS1JzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBnZXRPS1I6IGFzeW5jIChva3JJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL29rcnMvJHtva3JJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgT0tSICR7b2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBjcmVhdGVPS1I6IGFzeW5jIChva3JEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBIYW5kbGUgdGhlIG11bHRpLXVzZXIgYXNzaWdubWVudCBhbmQgYnVzaW5lc3MgdW5pdHMgaW4gdGhlIGJhY2tlbmRcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS9va3JzLycsIG9rckRhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIE9LUjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgdXBkYXRlT0tSOiBhc3luYyAob2tySWQsIG9rckRhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3JtYXQgdG8gbWF0Y2ggd2hhdCB0aGUgYmFja2VuZCBleHBlY3RzXHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkRGF0YSA9IHtcclxuICAgICAgICAuLi5va3JEYXRhLFxyXG4gICAgICAgIC8vIEZvciB1c2VyIG1hcHBpbmdzIC0gY29udmVydCBhc3NpZ25lZF91c2VycyB0byB0aGUgZm9ybWF0IGJhY2tlbmQgZXhwZWN0c1xyXG4gICAgICAgIGFzc2lnbmVkX3VzZXJfaWRzOiBva3JEYXRhLmFzc2lnbmVkX3VzZXJzID8gXHJcbiAgICAgICAgICBva3JEYXRhLmFzc2lnbmVkX3VzZXJzLm1hcCh1c2VyID0+IHVzZXIudXNlcl9pZCkgOiBcclxuICAgICAgICAgIFtdLFxyXG4gICAgICAgIC8vIFNldCBwcmltYXJ5IHVzZXJcclxuICAgICAgICBwcmltYXJ5X3VzZXJfaWQ6IG9rckRhdGEuYXNzaWduZWRfdXNlcnMgPyBcclxuICAgICAgICAgIG9rckRhdGEuYXNzaWduZWRfdXNlcnMuZmluZCh1c2VyID0+IHVzZXIuaXNfcHJpbWFyeSk/LnVzZXJfaWQgOiBcclxuICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gVXNlIGJ1c2luZXNzX3VuaXRfaWRzIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHVzZSBidXNpbmVzc191bml0c1xyXG4gICAgICAgIGJ1c2luZXNzX3VuaXRfaWRzOiBva3JEYXRhLmJ1c2luZXNzX3VuaXRfaWRzIHx8IG9rckRhdGEuYnVzaW5lc3NfdW5pdHMgfHwgW11cclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIFJlbW92ZSBmaWVsZHMgdGhlIGJhY2tlbmQgZG9lc24ndCBleHBlY3RcclxuICAgICAgaWYgKHRyYW5zZm9ybWVkRGF0YS5hc3NpZ25lZF91c2Vycykge1xyXG4gICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1lZERhdGEuYXNzaWduZWRfdXNlcnM7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmICh0cmFuc2Zvcm1lZERhdGEuYnVzaW5lc3NfdW5pdHMgJiYgdHJhbnNmb3JtZWREYXRhLmJ1c2luZXNzX3VuaXRfaWRzKSB7XHJcbiAgICAgICAgZGVsZXRlIHRyYW5zZm9ybWVkRGF0YS5idXNpbmVzc191bml0cztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gTG9nIHRoZSB0cmFuc2Zvcm1lZCBkYXRhIGJlaW5nIHNlbnRcclxuICAgICAgY29uc29sZS5sb2coJ0RhdGEgYmVpbmcgc2VudCB0byB1cGRhdGUgT0tSIEFQSTonLCB7XHJcbiAgICAgICAgZW5kcG9pbnQ6IGAvYXBpL29rcnMvJHtva3JJZH0vYCxcclxuICAgICAgICBvcmlnaW5hbDogb2tyRGF0YSxcclxuICAgICAgICB0cmFuc2Zvcm1lZDogdHJhbnNmb3JtZWREYXRhXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQoYC9hcGkvb2tycy8ke29rcklkfS9gLCB0cmFuc2Zvcm1lZERhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgZGVsZXRlT0tSOiBhc3luYyAob2tySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmRlbGV0ZShgL2FwaS9va3JzLyR7b2tySWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gQ2hpbGQgT0tScyAtIEdldCBPS1JzIHdpdGggYSBzcGVjaWZpYyBwYXJlbnRfb2tyXHJcbiAgZ2V0Q2hpbGRPS1JzOiBhc3luYyAocGFyZW50T2tySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS9va3JzLz9wYXJlbnRfb2tyPSR7cGFyZW50T2tySWR9YCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgY2hpbGQgT0tScyBmb3IgcGFyZW50ICR7cGFyZW50T2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBHZXQgYXNzaWduZWQgdXNlcnMgZm9yIGFuIE9LUlxyXG4gIGdldE9LUkFzc2lnbmVkVXNlcnM6IGFzeW5jIChva3JJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL29rcnMvJHtva3JJZH0vYXNzaWduZWRfdXNlcnMvYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgYXNzaWduZWQgdXNlcnMgZm9yIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gQWRkIGEgdXNlciB0byBhbiBPS1IgXHJcbiAgYWRkVXNlclRvT0tSOiBhc3luYyAob2tySWQsIHVzZXJEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvYXBpL29rcnMvJHtva3JJZH0vYXNzaWduX3VzZXIvYCwgdXNlckRhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFkZGluZyB1c2VyIHRvIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gUmVtb3ZlIGEgdXNlciBmcm9tIGFuIE9LUlxyXG4gIHJlbW92ZVVzZXJGcm9tT0tSOiBhc3luYyAob2tySWQsIHVzZXJJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZGVsZXRlKGAvYXBpL29rcnMvJHtva3JJZH0vcmVtb3ZlX3VzZXIvJHt1c2VySWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlbW92aW5nIHVzZXIgZnJvbSBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIFNldCBhIHVzZXIgYXMgcHJpbWFyeSBmb3IgYW4gT0tSXHJcbiAgc2V0UHJpbWFyeVVzZXJGb3JPS1I6IGFzeW5jIChva3JJZCwgdXNlcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvYXBpL29rcnMvJHtva3JJZH0vc2V0X3ByaW1hcnlfdXNlci9gLCB7IHVzZXJfaWQ6IHVzZXJJZCB9KTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzZXR0aW5nIHByaW1hcnkgdXNlciBmb3IgT0tSICR7b2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBUYXNrc1xyXG4gIGdldFRhc2tzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvdGFza3MvJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGFza3M6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGdldFRhc2s6IGFzeW5jICh0YXNrSWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS90YXNrcy8ke3Rhc2tJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgdGFzayAke3Rhc2tJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGNyZWF0ZVRhc2s6IGFzeW5jICh0YXNrRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS90YXNrcy8nLCB0YXNrRGF0YSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgdXBkYXRlVGFzazogYXN5bmMgKHRhc2tJZCwgdGFza0RhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnB1dChgL2FwaS90YXNrcy8ke3Rhc2tJZH0vYCwgdGFza0RhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIHRhc2sgJHt0YXNrSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBkZWxldGVUYXNrOiBhc3luYyAodGFza0lkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvdGFza3MvJHt0YXNrSWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIHRhc2sgJHt0YXNrSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBPS1IgVGFza3MgLSBHZXQgdGFza3MgZm9yIGEgc3BlY2lmaWMgT0tSXHJcbiAgZ2V0T0tSVGFza3M6IGFzeW5jIChva3JJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL3Rhc2tzLz9saW5rZWRfdG9fb2tyPSR7b2tySWR9YCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgdGFza3MgZm9yIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVXNlci1zcGVjaWZpYyBPS1JzIC0gbm93IHN1cHBvcnRzIGJvdGggYXNzaWduZWRfdG8gKGxlZ2FjeSkgYW5kIG9rcl91c2VyX21hcHBpbmdzXHJcbiAgZ2V0VXNlck9LUnM6IGFzeW5jICh1c2VySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS9va3JzL3VzZXIvJHt1c2VySWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIE9LUnMgZm9yIHVzZXIgJHt1c2VySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBVc2VyLXNwZWNpZmljIHRhc2tzXHJcbiAgZ2V0VXNlclRhc2tzOiBhc3luYyAodXNlcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvdGFza3MvP2Fzc2lnbmVkX3RvPSR7dXNlcklkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHRhc2tzIGZvciB1c2VyICR7dXNlcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIFRhc2tDaGFsbGVuZ2VzXHJcbiAgZ2V0VGFza0NoYWxsZW5nZXM6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldCgnL2FwaS90YXNrLWNoYWxsZW5nZXMvJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGFzayBjaGFsbGVuZ2VzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBnZXRUYXNrQ2hhbGxlbmdlOiBhc3luYyAoY2hhbGxlbmdlSWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS90YXNrLWNoYWxsZW5nZXMvJHtjaGFsbGVuZ2VJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgdGFzayBjaGFsbGVuZ2UgJHtjaGFsbGVuZ2VJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGNyZWF0ZVRhc2tDaGFsbGVuZ2U6IGFzeW5jIChjaGFsbGVuZ2VEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KCcvYXBpL3Rhc2stY2hhbGxlbmdlcy8nLCBjaGFsbGVuZ2VEYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyB0YXNrIGNoYWxsZW5nZTonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgdXBkYXRlVGFza0NoYWxsZW5nZTogYXN5bmMgKGNoYWxsZW5nZUlkLCBjaGFsbGVuZ2VEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQoYC9hcGkvdGFzay1jaGFsbGVuZ2VzLyR7Y2hhbGxlbmdlSWR9L2AsIGNoYWxsZW5nZURhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIHRhc2sgY2hhbGxlbmdlICR7Y2hhbGxlbmdlSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBkZWxldGVUYXNrQ2hhbGxlbmdlOiBhc3luYyAoY2hhbGxlbmdlSWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmRlbGV0ZShgL2FwaS90YXNrLWNoYWxsZW5nZXMvJHtjaGFsbGVuZ2VJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgdGFzayBjaGFsbGVuZ2UgJHtjaGFsbGVuZ2VJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIEdldCBjaGFsbGVuZ2VzIGZvciBhIHNwZWNpZmljIHRhc2tcclxuICBnZXRUYXNrQ2hhbGxlbmdlc0J5VGFzazogYXN5bmMgKHRhc2tJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL3Rhc2stY2hhbGxlbmdlcy9ieV90YXNrLz90YXNrX2lkPSR7dGFza0lkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNoYWxsZW5nZXMgZm9yIHRhc2sgJHt0YXNrSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFwaTsiXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImFwaUNsaWVudCIsImNyZWF0ZSIsImJhc2VVUkwiLCJoZWFkZXJzIiwidGltZW91dCIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJjb25zb2xlIiwibG9nIiwidXJsIiwiZXJyb3IiLCJQcm9taXNlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJkYXRhIiwic3RhdHVzIiwibWVzc2FnZSIsImFwaUNhbGxXaXRoUmV0cnkiLCJhcGlDYWxsIiwicmV0cnlDb3VudCIsImluaXRpYWxEZWxheU1zIiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsImNvZGUiLCJkZWxheU1zIiwiTWF0aCIsInBvdyIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiYXBpIiwiY2hlY2tCYWNrZW5kQ29ubmVjdGlvbiIsImdldCIsImxvZ2luIiwiY3JlZGVudGlhbHMiLCJwb3N0IiwiZ2V0RGVwYXJ0bWVudHMiLCJnZXRCdXNpbmVzc1VuaXRzIiwiZ2V0QnVzaW5lc3NVbml0IiwiYnVzaW5lc3NVbml0SWQiLCJjcmVhdGVCdXNpbmVzc1VuaXQiLCJidXNpbmVzc1VuaXREYXRhIiwidXBkYXRlQnVzaW5lc3NVbml0IiwicHV0IiwiZGVsZXRlQnVzaW5lc3NVbml0IiwiZGVsZXRlIiwiZ2V0T0tSQnVzaW5lc3NVbml0cyIsIm9rcklkIiwiYXNzaWduQnVzaW5lc3NVbml0c1RvT0tSIiwiYnVzaW5lc3NVbml0SWRzIiwiZ2V0VXNlcnMiLCJnZXRVc2VyIiwidXNlcklkIiwiZ2V0T0tScyIsImdldE9LUiIsImNyZWF0ZU9LUiIsIm9rckRhdGEiLCJ1cGRhdGVPS1IiLCJ0cmFuc2Zvcm1lZERhdGEiLCJhc3NpZ25lZF91c2VyX2lkcyIsImFzc2lnbmVkX3VzZXJzIiwibWFwIiwidXNlciIsInVzZXJfaWQiLCJwcmltYXJ5X3VzZXJfaWQiLCJmaW5kIiwiaXNfcHJpbWFyeSIsImJ1c2luZXNzX3VuaXRfaWRzIiwiYnVzaW5lc3NfdW5pdHMiLCJlbmRwb2ludCIsIm9yaWdpbmFsIiwidHJhbnNmb3JtZWQiLCJkZWxldGVPS1IiLCJnZXRDaGlsZE9LUnMiLCJwYXJlbnRPa3JJZCIsImdldE9LUkFzc2lnbmVkVXNlcnMiLCJhZGRVc2VyVG9PS1IiLCJ1c2VyRGF0YSIsInJlbW92ZVVzZXJGcm9tT0tSIiwic2V0UHJpbWFyeVVzZXJGb3JPS1IiLCJnZXRUYXNrcyIsImdldFRhc2siLCJ0YXNrSWQiLCJjcmVhdGVUYXNrIiwidGFza0RhdGEiLCJ1cGRhdGVUYXNrIiwiZGVsZXRlVGFzayIsImdldE9LUlRhc2tzIiwiZ2V0VXNlck9LUnMiLCJnZXRVc2VyVGFza3MiLCJnZXRUYXNrQ2hhbGxlbmdlcyIsImdldFRhc2tDaGFsbGVuZ2UiLCJjaGFsbGVuZ2VJZCIsImNyZWF0ZVRhc2tDaGFsbGVuZ2UiLCJjaGFsbGVuZ2VEYXRhIiwidXBkYXRlVGFza0NoYWxsZW5nZSIsImRlbGV0ZVRhc2tDaGFsbGVuZ2UiLCJnZXRUYXNrQ2hhbGxlbmdlc0J5VGFzayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/api.js\n"));

/***/ })

});