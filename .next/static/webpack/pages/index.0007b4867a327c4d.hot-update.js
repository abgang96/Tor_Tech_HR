"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./lib/api.js":
/*!********************!*\
  !*** ./lib/api.js ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n// Define API base URL\n// In a real app, this would be read from environment variables\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000\";\n// Create axios instance with default config\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    // Add longer timeout to handle potential network delays\n    timeout: 15000\n});\n// Add request interceptor to attach auth token\napiClient.interceptors.request.use((config)=>{\n    // Skip authentication for local development if needed\n    if (true) {\n        const token = localStorage.getItem(\"auth_token\");\n        if (token) {\n            config.headers[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n    }\n    console.log(\"Making request to: \".concat(config.baseURL).concat(config.url));\n    return config;\n}, (error)=>Promise.reject(error));\n// Add response interceptor for better error handling\napiClient.interceptors.response.use((response)=>response, (error)=>{\n    // Log better error information\n    if (error.response) {\n        var _error_config;\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        console.error(\"API Error Response:\", {\n            data: error.response.data,\n            status: error.response.status,\n            headers: error.response.headers,\n            url: (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url\n        });\n    } else if (error.request) {\n        var _error_config1, _error_config2;\n        // The request was made but no response was received\n        console.error(\"API No Response:\", {\n            request: error.request,\n            message: \"No response received from server. Is the backend running?\",\n            url: (_error_config1 = error.config) === null || _error_config1 === void 0 ? void 0 : _error_config1.url,\n            baseURL: (_error_config2 = error.config) === null || _error_config2 === void 0 ? void 0 : _error_config2.baseURL\n        });\n        console.log(\"Backend connectivity issue. Make sure Django server is running at:\", API_BASE_URL);\n    } else {\n        // Something happened in setting up the request that triggered an Error\n        console.error(\"API Request Error:\", error.message);\n    }\n    return Promise.reject(error);\n});\n// Helper function for retry logic\nconst apiCallWithRetry = async function(apiCall) {\n    let retryCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, initialDelayMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1000;\n    let lastError;\n    for(let attempt = 0; attempt < retryCount; attempt++){\n        try {\n            return await apiCall();\n        } catch (error) {\n            lastError = error;\n            // Only retry network or timeout errors\n            if (!error.code || error.code !== \"ERR_NETWORK\" && error.code !== \"ECONNABORTED\") {\n                throw error;\n            }\n            const delayMs = initialDelayMs * Math.pow(2, attempt);\n            console.log(\"Attempt \".concat(attempt + 1, \" failed, retrying in \").concat(delayMs, \"ms...\"));\n            await new Promise((resolve)=>setTimeout(resolve, delayMs));\n        }\n    }\n    throw lastError;\n};\n// Define API endpoints\nconst api = {\n    // Check API connectivity (new method)\n    checkBackendConnection: async ()=>{\n        try {\n            // Simple endpoint that should always be available\n            const response = await apiClient.get(\"/api/\");\n            console.log(\"Backend connection successful\");\n            return true;\n        } catch (error) {\n            console.error(\"Backend connection failed:\", error.message);\n            return false;\n        }\n    },\n    // Auth (Note: Your actual backend may have different auth endpoints)\n    login: async (credentials)=>{\n        try {\n            // This endpoint might need to be updated based on your actual backend auth endpoints\n            const response = await apiCallWithRetry(()=>apiClient.post(\"/api/token/\", credentials));\n            return response.data;\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        }\n    },\n    // Departments\n    getDepartments: async ()=>{\n        try {\n            console.log(\"Fetching departments from:\", \"\".concat(API_BASE_URL, \"/api/departments/\"));\n            const response = await apiCallWithRetry(()=>apiClient.get(\"/api/departments/\"));\n            console.log(\"Departments fetched successfully:\", response.data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching departments:\", error);\n            throw error;\n        }\n    },\n    // Business Units\n    getBusinessUnits: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/business-units/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business units:\", error);\n            throw error;\n        }\n    },\n    getBusinessUnit: async (businessUnitId)=>{\n        try {\n            const response = await apiClient.get(\"/api/business-units/\".concat(businessUnitId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    createBusinessUnit: async (businessUnitData)=>{\n        try {\n            const response = await apiClient.post(\"/api/business-units/\", businessUnitData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating business unit:\", error);\n            throw error;\n        }\n    },\n    updateBusinessUnit: async (businessUnitId, businessUnitData)=>{\n        try {\n            const response = await apiClient.put(\"/api/business-units/\".concat(businessUnitId, \"/\"), businessUnitData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteBusinessUnit: async (businessUnitId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/business-units/\".concat(businessUnitId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKR Business Units\n    getOKRBusinessUnits: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/business_units/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business units for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    assignBusinessUnitsToOKR: async (okrId, businessUnitIds)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/assign_business_units/\"), businessUnitIds);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error assigning business units to OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Users\n    getUsers: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/users/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching users:\", error);\n            throw error;\n        }\n    },\n    getUser: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/users/\".concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKRs\n    getOKRs: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKRs:\", error);\n            throw error;\n        }\n    },\n    getOKR: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    createOKR: async (okrData)=>{\n        try {\n            // Handle the multi-user assignment and business units in the backend\n            const response = await apiClient.post(\"/api/okrs/\", okrData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating OKR:\", error);\n            throw error;\n        }\n    },\n    updateOKR: async (okrId, okrData)=>{\n        try {\n            // Log the data being sent to the update OKR API\n            console.log(\"Data being sent to update OKR API:\", {\n                endpoint: \"/api/okrs/\".concat(okrId, \"/\"),\n                data: JSON.stringify(okrData, null, 2)\n            });\n            // Handle the multi-user assignment and business units in the backend\n            const response = await apiClient.put(\"/api/okrs/\".concat(okrId, \"/\"), okrData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteOKR: async (okrId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/okrs/\".concat(okrId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Child OKRs - Get OKRs with a specific parent_okr\n    getChildOKRs: async (parentOkrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/?parent_okr=\".concat(parentOkrId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching child OKRs for parent \".concat(parentOkrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Get assigned users for an OKR\n    getOKRAssignedUsers: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/assigned_users/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching assigned users for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Add a user to an OKR \n    addUserToOKR: async (okrId, userData)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/assign_user/\"), userData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error adding user to OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Remove a user from an OKR\n    removeUserFromOKR: async (okrId, userId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/okrs/\".concat(okrId, \"/remove_user/\").concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error removing user from OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Set a user as primary for an OKR\n    setPrimaryUserForOKR: async (okrId, userId)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/set_primary_user/\"), {\n                user_id: userId\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error setting primary user for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Tasks\n    getTasks: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks:\", error);\n            throw error;\n        }\n    },\n    getTask: async (taskId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/\".concat(taskId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    createTask: async (taskData)=>{\n        try {\n            const response = await apiClient.post(\"/api/tasks/\", taskData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating task:\", error);\n            throw error;\n        }\n    },\n    updateTask: async (taskId, taskData)=>{\n        try {\n            const response = await apiClient.put(\"/api/tasks/\".concat(taskId, \"/\"), taskData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteTask: async (taskId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/tasks/\".concat(taskId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKR Tasks - Get tasks for a specific OKR\n    getOKRTasks: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/?linked_to_okr=\".concat(okrId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // User-specific OKRs - now supports both assigned_to (legacy) and okr_user_mappings\n    getUserOKRs: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/user/\".concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKRs for user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // User-specific tasks\n    getUserTasks: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/?assigned_to=\".concat(userId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks for user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // TaskChallenges\n    getTaskChallenges: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task challenges:\", error);\n            throw error;\n        }\n    },\n    getTaskChallenge: async (challengeId)=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/\".concat(challengeId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    createTaskChallenge: async (challengeData)=>{\n        try {\n            const response = await apiClient.post(\"/api/task-challenges/\", challengeData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating task challenge:\", error);\n            throw error;\n        }\n    },\n    updateTaskChallenge: async (challengeId, challengeData)=>{\n        try {\n            const response = await apiClient.put(\"/api/task-challenges/\".concat(challengeId, \"/\"), challengeData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteTaskChallenge: async (challengeId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/task-challenges/\".concat(challengeId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    // Get challenges for a specific task\n    getTaskChallengesByTask: async (taskId)=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/by_task/?task_id=\".concat(taskId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching challenges for task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTJFLHFCQUFxQixPQUFPSjtRQUMxQixJQUFJO1lBQ0YsTUFBTXBFLFdBQVcsTUFBTWxCLFVBQVVpRCxNQUFNLENBQUMsd0JBQW9DLE9BQVpxQyxhQUFZO1lBQzVFLE9BQU9wRSxTQUFTQyxJQUFJO1FBQ3RCLEVBQUUsT0FBT0osT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsaUNBQTZDLE9BQVp1RSxhQUFZLE1BQUl2RTtZQUMvRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxxQ0FBcUM7SUFDckM0RSx5QkFBeUIsT0FBT2Y7UUFDOUIsSUFBSTtZQUNGLE1BQU0xRCxXQUFXLE1BQU1sQixVQUFVb0MsR0FBRyxDQUFDLHlDQUFnRCxPQUFQd0M7WUFDOUUsT0FBTzFELFNBQVNDLElBQUk7UUFDdEIsRUFBRSxPQUFPSixPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQyxzQ0FBNkMsT0FBUDZELFFBQU8sTUFBSTdEO1lBQy9ELE1BQU1BO1FBQ1I7SUFDRjtBQUNGO0FBRUEsK0RBQWVtQixHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGkuanM/NDU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5cclxuLy8gRGVmaW5lIEFQSSBiYXNlIFVSTFxyXG4vLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIHJlYWQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcclxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJztcclxuXHJcbi8vIENyZWF0ZSBheGlvcyBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgY29uZmlnXHJcbmNvbnN0IGFwaUNsaWVudCA9IGF4aW9zLmNyZWF0ZSh7XHJcbiAgYmFzZVVSTDogQVBJX0JBU0VfVVJMLFxyXG4gIGhlYWRlcnM6IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgfSxcclxuICAvLyBBZGQgbG9uZ2VyIHRpbWVvdXQgdG8gaGFuZGxlIHBvdGVudGlhbCBuZXR3b3JrIGRlbGF5c1xyXG4gIHRpbWVvdXQ6IDE1MDAwLFxyXG59KTtcclxuXHJcbi8vIEFkZCByZXF1ZXN0IGludGVyY2VwdG9yIHRvIGF0dGFjaCBhdXRoIHRva2VuXHJcbmFwaUNsaWVudC5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXHJcbiAgKGNvbmZpZykgPT4ge1xyXG4gICAgLy8gU2tpcCBhdXRoZW50aWNhdGlvbiBmb3IgbG9jYWwgZGV2ZWxvcG1lbnQgaWYgbmVlZGVkXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aF90b2tlbicpO1xyXG4gICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICBjb25maWcuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKGBNYWtpbmcgcmVxdWVzdCB0bzogJHtjb25maWcuYmFzZVVSTH0ke2NvbmZpZy51cmx9YCk7XHJcbiAgICByZXR1cm4gY29uZmlnO1xyXG4gIH0sXHJcbiAgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcilcclxuKTtcclxuXHJcbi8vIEFkZCByZXNwb25zZSBpbnRlcmNlcHRvciBmb3IgYmV0dGVyIGVycm9yIGhhbmRsaW5nXHJcbmFwaUNsaWVudC5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKFxyXG4gIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsXHJcbiAgKGVycm9yKSA9PiB7XHJcbiAgICAvLyBMb2cgYmV0dGVyIGVycm9yIGluZm9ybWF0aW9uXHJcbiAgICBpZiAoZXJyb3IucmVzcG9uc2UpIHtcclxuICAgICAgLy8gVGhlIHJlcXVlc3Qgd2FzIG1hZGUgYW5kIHRoZSBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYSBzdGF0dXMgY29kZVxyXG4gICAgICAvLyB0aGF0IGZhbGxzIG91dCBvZiB0aGUgcmFuZ2Ugb2YgMnh4XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvciBSZXNwb25zZTonLCB7XHJcbiAgICAgICAgZGF0YTogZXJyb3IucmVzcG9uc2UuZGF0YSxcclxuICAgICAgICBzdGF0dXM6IGVycm9yLnJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICBoZWFkZXJzOiBlcnJvci5yZXNwb25zZS5oZWFkZXJzLFxyXG4gICAgICAgIHVybDogZXJyb3IuY29uZmlnPy51cmwsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChlcnJvci5yZXF1ZXN0KSB7XHJcbiAgICAgIC8vIFRoZSByZXF1ZXN0IHdhcyBtYWRlIGJ1dCBubyByZXNwb25zZSB3YXMgcmVjZWl2ZWRcclxuICAgICAgY29uc29sZS5lcnJvcignQVBJIE5vIFJlc3BvbnNlOicsIHtcclxuICAgICAgICByZXF1ZXN0OiBlcnJvci5yZXF1ZXN0LFxyXG4gICAgICAgIG1lc3NhZ2U6ICdObyByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlci4gSXMgdGhlIGJhY2tlbmQgcnVubmluZz8nLFxyXG4gICAgICAgIHVybDogZXJyb3IuY29uZmlnPy51cmwsXHJcbiAgICAgICAgYmFzZVVSTDogZXJyb3IuY29uZmlnPy5iYXNlVVJMLFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc29sZS5sb2coJ0JhY2tlbmQgY29ubmVjdGl2aXR5IGlzc3VlLiBNYWtlIHN1cmUgRGphbmdvIHNlcnZlciBpcyBydW5uaW5nIGF0OicsIEFQSV9CQVNFX1VSTCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTb21ldGhpbmcgaGFwcGVuZWQgaW4gc2V0dGluZyB1cCB0aGUgcmVxdWVzdCB0aGF0IHRyaWdnZXJlZCBhbiBFcnJvclxyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgUmVxdWVzdCBFcnJvcjonLCBlcnJvci5tZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgfVxyXG4pO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciByZXRyeSBsb2dpY1xyXG5jb25zdCBhcGlDYWxsV2l0aFJldHJ5ID0gYXN5bmMgKGFwaUNhbGwsIHJldHJ5Q291bnQgPSAzLCBpbml0aWFsRGVsYXlNcyA9IDEwMDApID0+IHtcclxuICBsZXQgbGFzdEVycm9yO1xyXG4gIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgcmV0cnlDb3VudDsgYXR0ZW1wdCsrKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gYXdhaXQgYXBpQ2FsbCgpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbGFzdEVycm9yID0gZXJyb3I7XHJcbiAgICAgIC8vIE9ubHkgcmV0cnkgbmV0d29yayBvciB0aW1lb3V0IGVycm9yc1xyXG4gICAgICBpZiAoIWVycm9yLmNvZGUgfHwgKGVycm9yLmNvZGUgIT09ICdFUlJfTkVUV09SSycgJiYgZXJyb3IuY29kZSAhPT0gJ0VDT05OQUJPUlRFRCcpKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGRlbGF5TXMgPSBpbml0aWFsRGVsYXlNcyAqIE1hdGgucG93KDIsIGF0dGVtcHQpO1xyXG4gICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdCAke2F0dGVtcHQgKyAxfSBmYWlsZWQsIHJldHJ5aW5nIGluICR7ZGVsYXlNc31tcy4uLmApO1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlNcykpO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aHJvdyBsYXN0RXJyb3I7XHJcbn07XHJcblxyXG4vLyBEZWZpbmUgQVBJIGVuZHBvaW50c1xyXG5jb25zdCBhcGkgPSB7XHJcbiAgLy8gQ2hlY2sgQVBJIGNvbm5lY3Rpdml0eSAobmV3IG1ldGhvZClcclxuICBjaGVja0JhY2tlbmRDb25uZWN0aW9uOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTaW1wbGUgZW5kcG9pbnQgdGhhdCBzaG91bGQgYWx3YXlzIGJlIGF2YWlsYWJsZVxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvJyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdCYWNrZW5kIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bCcpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0JhY2tlbmQgY29ubmVjdGlvbiBmYWlsZWQ6JywgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIEF1dGggKE5vdGU6IFlvdXIgYWN0dWFsIGJhY2tlbmQgbWF5IGhhdmUgZGlmZmVyZW50IGF1dGggZW5kcG9pbnRzKVxyXG4gIGxvZ2luOiBhc3luYyAoY3JlZGVudGlhbHMpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRoaXMgZW5kcG9pbnQgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIHlvdXIgYWN0dWFsIGJhY2tlbmQgYXV0aCBlbmRwb2ludHNcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsV2l0aFJldHJ5KCgpID0+IGFwaUNsaWVudC5wb3N0KCcvYXBpL3Rva2VuLycsIGNyZWRlbnRpYWxzKSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTG9naW4gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIERlcGFydG1lbnRzXHJcbiAgZ2V0RGVwYXJ0bWVudHM6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBkZXBhcnRtZW50cyBmcm9tOicsIGAke0FQSV9CQVNFX1VSTH0vYXBpL2RlcGFydG1lbnRzL2ApO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNhbGxXaXRoUmV0cnkoKCkgPT4gYXBpQ2xpZW50LmdldCgnL2FwaS9kZXBhcnRtZW50cy8nKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdEZXBhcnRtZW50cyBmZXRjaGVkIHN1Y2Nlc3NmdWxseTonLCByZXNwb25zZS5kYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBkZXBhcnRtZW50czonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gQnVzaW5lc3MgVW5pdHNcclxuICBnZXRCdXNpbmVzc1VuaXRzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvYnVzaW5lc3MtdW5pdHMvJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYnVzaW5lc3MgdW5pdHM6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGdldEJ1c2luZXNzVW5pdDogYXN5bmMgKGJ1c2luZXNzVW5pdElkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvYnVzaW5lc3MtdW5pdHMvJHtidXNpbmVzc1VuaXRJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgYnVzaW5lc3MgdW5pdCAke2J1c2luZXNzVW5pdElkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgY3JlYXRlQnVzaW5lc3NVbml0OiBhc3luYyAoYnVzaW5lc3NVbml0RGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS9idXNpbmVzcy11bml0cy8nLCBidXNpbmVzc1VuaXREYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBidXNpbmVzcyB1bml0OicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICB1cGRhdGVCdXNpbmVzc1VuaXQ6IGFzeW5jIChidXNpbmVzc1VuaXRJZCwgYnVzaW5lc3NVbml0RGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucHV0KGAvYXBpL2J1c2luZXNzLXVuaXRzLyR7YnVzaW5lc3NVbml0SWR9L2AsIGJ1c2luZXNzVW5pdERhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIGJ1c2luZXNzIHVuaXQgJHtidXNpbmVzc1VuaXRJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGRlbGV0ZUJ1c2luZXNzVW5pdDogYXN5bmMgKGJ1c2luZXNzVW5pdElkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvYnVzaW5lc3MtdW5pdHMvJHtidXNpbmVzc1VuaXRJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgYnVzaW5lc3MgdW5pdCAke2J1c2luZXNzVW5pdElkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gT0tSIEJ1c2luZXNzIFVuaXRzXHJcbiAgZ2V0T0tSQnVzaW5lc3NVbml0czogYXN5bmMgKG9rcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvb2tycy8ke29rcklkfS9idXNpbmVzc191bml0cy9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBidXNpbmVzcyB1bml0cyBmb3IgT0tSICR7b2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBhc3NpZ25CdXNpbmVzc1VuaXRzVG9PS1I6IGFzeW5jIChva3JJZCwgYnVzaW5lc3NVbml0SWRzKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvYXBpL29rcnMvJHtva3JJZH0vYXNzaWduX2J1c2luZXNzX3VuaXRzL2AsIGJ1c2luZXNzVW5pdElkcyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYXNzaWduaW5nIGJ1c2luZXNzIHVuaXRzIHRvIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVXNlcnNcclxuICBnZXRVc2VyczogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KCcvYXBpL3VzZXJzLycpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHVzZXJzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBnZXRVc2VyOiBhc3luYyAodXNlcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvdXNlcnMvJHt1c2VySWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHVzZXIgJHt1c2VySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBPS1JzXHJcbiAgZ2V0T0tSczogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KCcvYXBpL29rcnMvJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgT0tSczonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgZ2V0T0tSOiBhc3luYyAob2tySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS9va3JzLyR7b2tySWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgY3JlYXRlT0tSOiBhc3luYyAob2tyRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gSGFuZGxlIHRoZSBtdWx0aS11c2VyIGFzc2lnbm1lbnQgYW5kIGJ1c2luZXNzIHVuaXRzIGluIHRoZSBiYWNrZW5kXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoJy9hcGkvb2tycy8nLCBva3JEYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBPS1I6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIHVwZGF0ZU9LUjogYXN5bmMgKG9rcklkLCBva3JEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBMb2cgdGhlIGRhdGEgYmVpbmcgc2VudCB0byB0aGUgdXBkYXRlIE9LUiBBUElcclxuICAgICAgY29uc29sZS5sb2coJ0RhdGEgYmVpbmcgc2VudCB0byB1cGRhdGUgT0tSIEFQSTonLCB7XHJcbiAgICAgICAgZW5kcG9pbnQ6IGAvYXBpL29rcnMvJHtva3JJZH0vYCxcclxuICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShva3JEYXRhLCBudWxsLCAyKVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIC8vIEhhbmRsZSB0aGUgbXVsdGktdXNlciBhc3NpZ25tZW50IGFuZCBidXNpbmVzcyB1bml0cyBpbiB0aGUgYmFja2VuZFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQoYC9hcGkvb2tycy8ke29rcklkfS9gLCBva3JEYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1cGRhdGluZyBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGRlbGV0ZU9LUjogYXN5bmMgKG9rcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvb2tycy8ke29rcklkfS9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZWxldGluZyBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIENoaWxkIE9LUnMgLSBHZXQgT0tScyB3aXRoIGEgc3BlY2lmaWMgcGFyZW50X29rclxyXG4gIGdldENoaWxkT0tSczogYXN5bmMgKHBhcmVudE9rcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvb2tycy8/cGFyZW50X29rcj0ke3BhcmVudE9rcklkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNoaWxkIE9LUnMgZm9yIHBhcmVudCAke3BhcmVudE9rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gR2V0IGFzc2lnbmVkIHVzZXJzIGZvciBhbiBPS1JcclxuICBnZXRPS1JBc3NpZ25lZFVzZXJzOiBhc3luYyAob2tySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS9va3JzLyR7b2tySWR9L2Fzc2lnbmVkX3VzZXJzL2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGFzc2lnbmVkIHVzZXJzIGZvciBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIEFkZCBhIHVzZXIgdG8gYW4gT0tSIFxyXG4gIGFkZFVzZXJUb09LUjogYXN5bmMgKG9rcklkLCB1c2VyRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdChgL2FwaS9va3JzLyR7b2tySWR9L2Fzc2lnbl91c2VyL2AsIHVzZXJEYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhZGRpbmcgdXNlciB0byBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIFJlbW92ZSBhIHVzZXIgZnJvbSBhbiBPS1JcclxuICByZW1vdmVVc2VyRnJvbU9LUjogYXN5bmMgKG9rcklkLCB1c2VySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmRlbGV0ZShgL2FwaS9va3JzLyR7b2tySWR9L3JlbW92ZV91c2VyLyR7dXNlcklkfS9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZW1vdmluZyB1c2VyIGZyb20gT0tSICR7b2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBTZXQgYSB1c2VyIGFzIHByaW1hcnkgZm9yIGFuIE9LUlxyXG4gIHNldFByaW1hcnlVc2VyRm9yT0tSOiBhc3luYyAob2tySWQsIHVzZXJJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdChgL2FwaS9va3JzLyR7b2tySWR9L3NldF9wcmltYXJ5X3VzZXIvYCwgeyB1c2VyX2lkOiB1c2VySWQgfSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2V0dGluZyBwcmltYXJ5IHVzZXIgZm9yIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVGFza3NcclxuICBnZXRUYXNrczogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KCcvYXBpL3Rhc2tzLycpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRhc2tzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBnZXRUYXNrOiBhc3luYyAodGFza0lkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvdGFza3MvJHt0YXNrSWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHRhc2sgJHt0YXNrSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBjcmVhdGVUYXNrOiBhc3luYyAodGFza0RhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoJy9hcGkvdGFza3MvJywgdGFza0RhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHRhc2s6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIHVwZGF0ZVRhc2s6IGFzeW5jICh0YXNrSWQsIHRhc2tEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQoYC9hcGkvdGFza3MvJHt0YXNrSWR9L2AsIHRhc2tEYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1cGRhdGluZyB0YXNrICR7dGFza0lkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgZGVsZXRlVGFzazogYXN5bmMgKHRhc2tJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZGVsZXRlKGAvYXBpL3Rhc2tzLyR7dGFza0lkfS9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZWxldGluZyB0YXNrICR7dGFza0lkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gT0tSIFRhc2tzIC0gR2V0IHRhc2tzIGZvciBhIHNwZWNpZmljIE9LUlxyXG4gIGdldE9LUlRhc2tzOiBhc3luYyAob2tySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS90YXNrcy8/bGlua2VkX3RvX29rcj0ke29rcklkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHRhc2tzIGZvciBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIFVzZXItc3BlY2lmaWMgT0tScyAtIG5vdyBzdXBwb3J0cyBib3RoIGFzc2lnbmVkX3RvIChsZWdhY3kpIGFuZCBva3JfdXNlcl9tYXBwaW5nc1xyXG4gIGdldFVzZXJPS1JzOiBhc3luYyAodXNlcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvb2tycy91c2VyLyR7dXNlcklkfS9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBPS1JzIGZvciB1c2VyICR7dXNlcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVXNlci1zcGVjaWZpYyB0YXNrc1xyXG4gIGdldFVzZXJUYXNrczogYXN5bmMgKHVzZXJJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL3Rhc2tzLz9hc3NpZ25lZF90bz0ke3VzZXJJZH1gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyB0YXNrcyBmb3IgdXNlciAke3VzZXJJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBUYXNrQ2hhbGxlbmdlc1xyXG4gIGdldFRhc2tDaGFsbGVuZ2VzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvdGFzay1jaGFsbGVuZ2VzLycpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRhc2sgY2hhbGxlbmdlczonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgZ2V0VGFza0NoYWxsZW5nZTogYXN5bmMgKGNoYWxsZW5nZUlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvdGFzay1jaGFsbGVuZ2VzLyR7Y2hhbGxlbmdlSWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHRhc2sgY2hhbGxlbmdlICR7Y2hhbGxlbmdlSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBjcmVhdGVUYXNrQ2hhbGxlbmdlOiBhc3luYyAoY2hhbGxlbmdlRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS90YXNrLWNoYWxsZW5nZXMvJywgY2hhbGxlbmdlRGF0YSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdGFzayBjaGFsbGVuZ2U6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIHVwZGF0ZVRhc2tDaGFsbGVuZ2U6IGFzeW5jIChjaGFsbGVuZ2VJZCwgY2hhbGxlbmdlRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucHV0KGAvYXBpL3Rhc2stY2hhbGxlbmdlcy8ke2NoYWxsZW5nZUlkfS9gLCBjaGFsbGVuZ2VEYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1cGRhdGluZyB0YXNrIGNoYWxsZW5nZSAke2NoYWxsZW5nZUlkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgZGVsZXRlVGFza0NoYWxsZW5nZTogYXN5bmMgKGNoYWxsZW5nZUlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvdGFzay1jaGFsbGVuZ2VzLyR7Y2hhbGxlbmdlSWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIHRhc2sgY2hhbGxlbmdlICR7Y2hhbGxlbmdlSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBHZXQgY2hhbGxlbmdlcyBmb3IgYSBzcGVjaWZpYyB0YXNrXHJcbiAgZ2V0VGFza0NoYWxsZW5nZXNCeVRhc2s6IGFzeW5jICh0YXNrSWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS90YXNrLWNoYWxsZW5nZXMvYnlfdGFzay8/dGFza19pZD0ke3Rhc2tJZH1gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjaGFsbGVuZ2VzIGZvciB0YXNrICR7dGFza0lkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhcGk7Il0sIm5hbWVzIjpbImF4aW9zIiwiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJhcGlDbGllbnQiLCJjcmVhdGUiLCJiYXNlVVJMIiwiaGVhZGVycyIsInRpbWVvdXQiLCJpbnRlcmNlcHRvcnMiLCJyZXF1ZXN0IiwidXNlIiwiY29uZmlnIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiY29uc29sZSIsImxvZyIsInVybCIsImVycm9yIiwiUHJvbWlzZSIsInJlamVjdCIsInJlc3BvbnNlIiwiZGF0YSIsInN0YXR1cyIsIm1lc3NhZ2UiLCJhcGlDYWxsV2l0aFJldHJ5IiwiYXBpQ2FsbCIsInJldHJ5Q291bnQiLCJpbml0aWFsRGVsYXlNcyIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJjb2RlIiwiZGVsYXlNcyIsIk1hdGgiLCJwb3ciLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImFwaSIsImNoZWNrQmFja2VuZENvbm5lY3Rpb24iLCJnZXQiLCJsb2dpbiIsImNyZWRlbnRpYWxzIiwicG9zdCIsImdldERlcGFydG1lbnRzIiwiZ2V0QnVzaW5lc3NVbml0cyIsImdldEJ1c2luZXNzVW5pdCIsImJ1c2luZXNzVW5pdElkIiwiY3JlYXRlQnVzaW5lc3NVbml0IiwiYnVzaW5lc3NVbml0RGF0YSIsInVwZGF0ZUJ1c2luZXNzVW5pdCIsInB1dCIsImRlbGV0ZUJ1c2luZXNzVW5pdCIsImRlbGV0ZSIsImdldE9LUkJ1c2luZXNzVW5pdHMiLCJva3JJZCIsImFzc2lnbkJ1c2luZXNzVW5pdHNUb09LUiIsImJ1c2luZXNzVW5pdElkcyIsImdldFVzZXJzIiwiZ2V0VXNlciIsInVzZXJJZCIsImdldE9LUnMiLCJnZXRPS1IiLCJjcmVhdGVPS1IiLCJva3JEYXRhIiwidXBkYXRlT0tSIiwiZW5kcG9pbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVsZXRlT0tSIiwiZ2V0Q2hpbGRPS1JzIiwicGFyZW50T2tySWQiLCJnZXRPS1JBc3NpZ25lZFVzZXJzIiwiYWRkVXNlclRvT0tSIiwidXNlckRhdGEiLCJyZW1vdmVVc2VyRnJvbU9LUiIsInNldFByaW1hcnlVc2VyRm9yT0tSIiwidXNlcl9pZCIsImdldFRhc2tzIiwiZ2V0VGFzayIsInRhc2tJZCIsImNyZWF0ZVRhc2siLCJ0YXNrRGF0YSIsInVwZGF0ZVRhc2siLCJkZWxldGVUYXNrIiwiZ2V0T0tSVGFza3MiLCJnZXRVc2VyT0tScyIsImdldFVzZXJUYXNrcyIsImdldFRhc2tDaGFsbGVuZ2VzIiwiZ2V0VGFza0NoYWxsZW5nZSIsImNoYWxsZW5nZUlkIiwiY3JlYXRlVGFza0NoYWxsZW5nZSIsImNoYWxsZW5nZURhdGEiLCJ1cGRhdGVUYXNrQ2hhbGxlbmdlIiwiZGVsZXRlVGFza0NoYWxsZW5nZSIsImdldFRhc2tDaGFsbGVuZ2VzQnlUYXNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/api.js\n"));

/***/ })

});