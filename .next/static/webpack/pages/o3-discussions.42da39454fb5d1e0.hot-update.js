"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/o3-discussions",{

/***/ "./lib/api.js":
/*!********************!*\
  !*** ./lib/api.js ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n// Define API base URL\n// In a real app, this would be read from environment variables\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000\";\n// Create axios instance with default config\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    // Add longer timeout to handle potential network delays\n    timeout: 15000\n});\n// Add request interceptor to attach auth token\napiClient.interceptors.request.use((config)=>{\n    // Skip authentication for local development if needed\n    if (true) {\n        const token = localStorage.getItem(\"auth_token\");\n        if (token) {\n            config.headers[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n    }\n    console.log(\"Making request to: \".concat(config.baseURL).concat(config.url));\n    return config;\n}, (error)=>Promise.reject(error));\n// Add response interceptor for better error handling\napiClient.interceptors.response.use((response)=>response, (error)=>{\n    // Log better error information\n    if (error.response) {\n        var _error_config;\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        console.error(\"API Error Response:\", {\n            data: error.response.data,\n            status: error.response.status,\n            headers: error.response.headers,\n            url: (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url\n        });\n    } else if (error.request) {\n        var _error_config1, _error_config2;\n        // The request was made but no response was received\n        console.error(\"API No Response:\", {\n            request: error.request,\n            message: \"No response received from server. Is the backend running?\",\n            url: (_error_config1 = error.config) === null || _error_config1 === void 0 ? void 0 : _error_config1.url,\n            baseURL: (_error_config2 = error.config) === null || _error_config2 === void 0 ? void 0 : _error_config2.baseURL\n        });\n        console.log(\"Backend connectivity issue. Make sure Django server is running at:\", API_BASE_URL);\n    } else {\n        // Something happened in setting up the request that triggered an Error\n        console.error(\"API Request Error:\", error.message);\n    }\n    return Promise.reject(error);\n});\n// Helper function for retry logic\nconst apiCallWithRetry = async function(apiCall) {\n    let retryCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, initialDelayMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1000;\n    let lastError;\n    for(let attempt = 0; attempt < retryCount; attempt++){\n        try {\n            return await apiCall();\n        } catch (error) {\n            lastError = error;\n            // Only retry network or timeout errors\n            if (!error.code || error.code !== \"ERR_NETWORK\" && error.code !== \"ECONNABORTED\") {\n                throw error;\n            }\n            const delayMs = initialDelayMs * Math.pow(2, attempt);\n            console.log(\"Attempt \".concat(attempt + 1, \" failed, retrying in \").concat(delayMs, \"ms...\"));\n            await new Promise((resolve)=>setTimeout(resolve, delayMs));\n        }\n    }\n    throw lastError;\n};\n// Define API endpoints\nconst api = {\n    // Check API connectivity (new method)\n    checkBackendConnection: async ()=>{\n        try {\n            // Simple endpoint that should always be available\n            const response = await apiClient.get(\"/api/\");\n            console.log(\"Backend connection successful\");\n            return true;\n        } catch (error) {\n            console.error(\"Backend connection failed:\", error.message);\n            return false;\n        }\n    },\n    // Auth (Note: Your actual backend may have different auth endpoints)\n    login: async (credentials)=>{\n        try {\n            // This endpoint might need to be updated based on your actual backend auth endpoints\n            const response = await apiCallWithRetry(()=>apiClient.post(\"/api/token/\", credentials));\n            return response.data;\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        }\n    },\n    // Departments\n    getDepartments: async ()=>{\n        try {\n            console.log(\"Fetching departments from:\", \"\".concat(API_BASE_URL, \"/api/departments/\"));\n            const response = await apiCallWithRetry(()=>apiClient.get(\"/api/departments/\"));\n            console.log(\"Departments fetched successfully:\", response.data);\n            // Return empty array if the data is null or undefined\n            return response.data || [];\n        } catch (error) {\n            console.error(\"Error fetching departments:\", error);\n            // Return empty array on error to prevent UI breaking\n            return [];\n        }\n    },\n    // Business Units\n    getBusinessUnits: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/business-units/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business units:\", error);\n            throw error;\n        }\n    },\n    getBusinessUnit: async (businessUnitId)=>{\n        try {\n            const response = await apiClient.get(\"/api/business-units/\".concat(businessUnitId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    createBusinessUnit: async (businessUnitData)=>{\n        try {\n            const response = await apiClient.post(\"/api/business-units/\", businessUnitData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating business unit:\", error);\n            throw error;\n        }\n    },\n    updateBusinessUnit: async (businessUnitId, businessUnitData)=>{\n        try {\n            const response = await apiClient.put(\"/api/business-units/\".concat(businessUnitId, \"/\"), businessUnitData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteBusinessUnit: async (businessUnitId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/business-units/\".concat(businessUnitId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKR Business Units\n    getOKRBusinessUnits: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/business_units/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business units for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    assignBusinessUnitsToOKR: async (okrId, businessUnitIds)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/assign_business_units/\"), businessUnitIds);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error assigning business units to OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Users\n    getUsers: async ()=>{\n        try {\n            console.log(\"Fetching users from:\", \"\".concat(API_BASE_URL, \"/api/users/\"));\n            const response = await apiCallWithRetry(()=>apiClient.get(\"/api/users/\"));\n            console.log(\"Users fetched successfully:\", response.data);\n            // Return empty array if the data is null or undefined\n            return response.data || [];\n        } catch (error) {\n            console.error(\"Error fetching users:\", error);\n            // Return empty array on error to prevent UI breaking\n            return [];\n        }\n    },\n    getUser: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/users/\".concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKRs\n    getOKRs: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKRs:\", error);\n            throw error;\n        }\n    },\n    getOKR: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    createOKR: async (okrData)=>{\n        try {\n            // Transform the data format to match what the backend expects\n            const transformedData = {\n                ...okrData,\n                // Map title to name if title exists\n                name: okrData.title,\n                // For user mappings - convert assigned_users to the format backend expects\n                assigned_user_ids: okrData.assigned_user_ids || [],\n                // Set primary user\n                primary_user_id: okrData.primary_user_id || null,\n                // Use business_unit_ids if it exists\n                business_unit_ids: okrData.business_unit_ids || []\n            };\n            // Remove title field as we've transformed it to name\n            if (transformedData.title) {\n                delete transformedData.title;\n            }\n            // Log the transformed data being sent\n            console.log(\"Data being sent to create OKR API:\", {\n                endpoint: \"/api/okrs/\",\n                original: okrData,\n                transformed: transformedData\n            });\n            // Handle the multi-user assignment and business units in the backend\n            const response = await apiClient.post(\"/api/okrs/\", transformedData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating OKR:\", error);\n            throw error;\n        }\n    },\n    updateOKR: async (okrId, okrData)=>{\n        try {\n            var _okrData_assigned_users_find;\n            // Transform the data format to match what the backend expects\n            const transformedData = {\n                ...okrData,\n                // For user mappings - convert assigned_users to the format backend expects\n                assigned_user_ids: okrData.assigned_users ? okrData.assigned_users.map((user)=>user.user_id) : [],\n                // Set primary user\n                primary_user_id: okrData.assigned_users ? (_okrData_assigned_users_find = okrData.assigned_users.find((user)=>user.is_primary)) === null || _okrData_assigned_users_find === void 0 ? void 0 : _okrData_assigned_users_find.user_id : null,\n                // Use business_unit_ids if it exists, otherwise use business_units\n                business_unit_ids: okrData.business_unit_ids || okrData.business_units || []\n            };\n            // Remove fields the backend doesn't expect\n            if (transformedData.assigned_users) {\n                delete transformedData.assigned_users;\n            }\n            if (transformedData.business_units && transformedData.business_unit_ids) {\n                delete transformedData.business_units;\n            }\n            // Log the transformed data being sent\n            console.log(\"Data being sent to update OKR API:\", {\n                endpoint: \"/api/okrs/\".concat(okrId, \"/\"),\n                original: okrData,\n                transformed: transformedData\n            });\n            // Send the request\n            const response = await apiClient.put(\"/api/okrs/\".concat(okrId, \"/\"), transformedData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteOKR: async (okrId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/okrs/\".concat(okrId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Child OKRs - Get OKRs with a specific parent_okr\n    getChildOKRs: async (parentOkrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/?parent_okr=\".concat(parentOkrId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching child OKRs for parent \".concat(parentOkrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Get assigned users for an OKR\n    getOKRAssignedUsers: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/assigned_users/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching assigned users for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Add a user to an OKR \n    addUserToOKR: async (okrId, userData)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/assign_user/\"), userData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error adding user to OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Remove a user from an OKR\n    removeUserFromOKR: async (okrId, userId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/okrs/\".concat(okrId, \"/remove_user/\").concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error removing user from OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Set a user as primary for an OKR\n    setPrimaryUserForOKR: async (okrId, userId)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/set_primary_user/\"), {\n                user_id: userId\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error setting primary user for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Tasks\n    getTasks: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks:\", error);\n            throw error;\n        }\n    },\n    getTask: async (taskId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/\".concat(taskId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    createTask: async (taskData)=>{\n        try {\n            const response = await apiClient.post(\"/api/tasks/\", taskData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating task:\", error);\n            throw error;\n        }\n    },\n    updateTask: async (taskId, taskData)=>{\n        try {\n            const response = await apiClient.put(\"/api/tasks/\".concat(taskId, \"/\"), taskData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteTask: async (taskId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/tasks/\".concat(taskId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKR Tasks - Get tasks for a specific OKR\n    getOKRTasks: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/?linked_to_okr=\".concat(okrId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // User-specific OKRs - now supports both assigned_to (legacy) and okr_user_mappings\n    getUserOKRs: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/user/\".concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKRs for user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // User-specific tasks\n    getUserTasks: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/?assigned_to=\".concat(userId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks for user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // TaskChallenges\n    getTaskChallenges: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task challenges:\", error);\n            throw error;\n        }\n    },\n    getTaskChallenge: async (challengeId)=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/\".concat(challengeId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    createTaskChallenge: async (challengeData)=>{\n        try {\n            const response = await apiClient.post(\"/api/task-challenges/\", challengeData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating task challenge:\", error);\n            throw error;\n        }\n    },\n    updateTaskChallenge: async (challengeId, challengeData)=>{\n        try {\n            const response = await apiClient.put(\"/api/task-challenges/\".concat(challengeId, \"/\"), challengeData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteTaskChallenge: async (challengeId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/task-challenges/\".concat(challengeId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    // Get challenges for a specific task\n    getTaskChallengesByTask: async (taskId)=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/by_task/?task_id=\".concat(taskId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching challenges for task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c0YscUJBQXFCLE9BQU9ILGFBQWFFO1FBQ3ZDLElBQUk7WUFDRixNQUFNbEYsV0FBVyxNQUFNbEIsVUFBVStDLEdBQUcsQ0FBQyx3QkFBb0MsT0FBWm1ELGFBQVksTUFBSUU7WUFDN0UsT0FBT2xGLFNBQVNDLElBQUk7UUFDdEIsRUFBRSxPQUFPSixPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQyxpQ0FBNkMsT0FBWm1GLGFBQVksTUFBSW5GO1lBQy9ELE1BQU1BO1FBQ1I7SUFDRjtJQUVBdUYscUJBQXFCLE9BQU9KO1FBQzFCLElBQUk7WUFDRixNQUFNaEYsV0FBVyxNQUFNbEIsVUFBVWlELE1BQU0sQ0FBQyx3QkFBb0MsT0FBWmlELGFBQVk7WUFDNUUsT0FBT2hGLFNBQVNDLElBQUk7UUFDdEIsRUFBRSxPQUFPSixPQUFPO1lBQ2RILFFBQVFHLEtBQUssQ0FBQyxpQ0FBNkMsT0FBWm1GLGFBQVksTUFBSW5GO1lBQy9ELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLHFDQUFxQztJQUNyQ3dGLHlCQUF5QixPQUFPZjtRQUM5QixJQUFJO1lBQ0YsTUFBTXRFLFdBQVcsTUFBTWxCLFVBQVVvQyxHQUFHLENBQUMseUNBQWdELE9BQVBvRDtZQUM5RSxPQUFPdEUsU0FBU0MsSUFBSTtRQUN0QixFQUFFLE9BQU9KLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLHNDQUE2QyxPQUFQeUUsUUFBTyxNQUFJekU7WUFDL0QsTUFBTUE7UUFDUjtJQUNGO0FBQ0Y7QUFFQSwrREFBZW1CLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS5qcz80NTQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XHJcblxyXG4vLyBEZWZpbmUgQVBJIGJhc2UgVVJMXHJcbi8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYmUgcmVhZCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnO1xyXG5cclxuLy8gQ3JlYXRlIGF4aW9zIGluc3RhbmNlIHdpdGggZGVmYXVsdCBjb25maWdcclxuY29uc3QgYXBpQ2xpZW50ID0gYXhpb3MuY3JlYXRlKHtcclxuICBiYXNlVVJMOiBBUElfQkFTRV9VUkwsXHJcbiAgaGVhZGVyczoge1xyXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICB9LFxyXG4gIC8vIEFkZCBsb25nZXIgdGltZW91dCB0byBoYW5kbGUgcG90ZW50aWFsIG5ldHdvcmsgZGVsYXlzXHJcbiAgdGltZW91dDogMTUwMDAsXHJcbn0pO1xyXG5cclxuLy8gQWRkIHJlcXVlc3QgaW50ZXJjZXB0b3IgdG8gYXR0YWNoIGF1dGggdG9rZW5cclxuYXBpQ2xpZW50LmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcclxuICAoY29uZmlnKSA9PiB7XHJcbiAgICAvLyBTa2lwIGF1dGhlbnRpY2F0aW9uIGZvciBsb2NhbCBkZXZlbG9wbWVudCBpZiBuZWVkZWRcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoX3Rva2VuJyk7XHJcbiAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgIGNvbmZpZy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coYE1ha2luZyByZXF1ZXN0IHRvOiAke2NvbmZpZy5iYXNlVVJMfSR7Y29uZmlnLnVybH1gKTtcclxuICAgIHJldHVybiBjb25maWc7XHJcbiAgfSxcclxuICAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKVxyXG4pO1xyXG5cclxuLy8gQWRkIHJlc3BvbnNlIGludGVyY2VwdG9yIGZvciBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcclxuYXBpQ2xpZW50LmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXHJcbiAgKHJlc3BvbnNlKSA9PiByZXNwb25zZSxcclxuICAoZXJyb3IpID0+IHtcclxuICAgIC8vIExvZyBiZXR0ZXIgZXJyb3IgaW5mb3JtYXRpb25cclxuICAgIGlmIChlcnJvci5yZXNwb25zZSkge1xyXG4gICAgICAvLyBUaGUgcmVxdWVzdCB3YXMgbWFkZSBhbmQgdGhlIHNlcnZlciByZXNwb25kZWQgd2l0aCBhIHN0YXR1cyBjb2RlXHJcbiAgICAgIC8vIHRoYXQgZmFsbHMgb3V0IG9mIHRoZSByYW5nZSBvZiAyeHhcclxuICAgICAgY29uc29sZS5lcnJvcignQVBJIEVycm9yIFJlc3BvbnNlOicsIHtcclxuICAgICAgICBkYXRhOiBlcnJvci5yZXNwb25zZS5kYXRhLFxyXG4gICAgICAgIHN0YXR1czogZXJyb3IucmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgIGhlYWRlcnM6IGVycm9yLnJlc3BvbnNlLmhlYWRlcnMsXHJcbiAgICAgICAgdXJsOiBlcnJvci5jb25maWc/LnVybCxcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKGVycm9yLnJlcXVlc3QpIHtcclxuICAgICAgLy8gVGhlIHJlcXVlc3Qgd2FzIG1hZGUgYnV0IG5vIHJlc3BvbnNlIHdhcyByZWNlaXZlZFxyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgTm8gUmVzcG9uc2U6Jywge1xyXG4gICAgICAgIHJlcXVlc3Q6IGVycm9yLnJlcXVlc3QsXHJcbiAgICAgICAgbWVzc2FnZTogJ05vIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyLiBJcyB0aGUgYmFja2VuZCBydW5uaW5nPycsXHJcbiAgICAgICAgdXJsOiBlcnJvci5jb25maWc/LnVybCxcclxuICAgICAgICBiYXNlVVJMOiBlcnJvci5jb25maWc/LmJhc2VVUkwsXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zb2xlLmxvZygnQmFja2VuZCBjb25uZWN0aXZpdHkgaXNzdWUuIE1ha2Ugc3VyZSBEamFuZ28gc2VydmVyIGlzIHJ1bm5pbmcgYXQ6JywgQVBJX0JBU0VfVVJMKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFNvbWV0aGluZyBoYXBwZW5lZCBpbiBzZXR0aW5nIHVwIHRoZSByZXF1ZXN0IHRoYXQgdHJpZ2dlcmVkIGFuIEVycm9yXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBSZXF1ZXN0IEVycm9yOicsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICB9XHJcbik7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHJldHJ5IGxvZ2ljXHJcbmNvbnN0IGFwaUNhbGxXaXRoUmV0cnkgPSBhc3luYyAoYXBpQ2FsbCwgcmV0cnlDb3VudCA9IDMsIGluaXRpYWxEZWxheU1zID0gMTAwMCkgPT4ge1xyXG4gIGxldCBsYXN0RXJyb3I7XHJcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCByZXRyeUNvdW50OyBhdHRlbXB0KyspIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCBhcGlDYWxsKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcclxuICAgICAgLy8gT25seSByZXRyeSBuZXR3b3JrIG9yIHRpbWVvdXQgZXJyb3JzXHJcbiAgICAgIGlmICghZXJyb3IuY29kZSB8fCAoZXJyb3IuY29kZSAhPT0gJ0VSUl9ORVRXT1JLJyAmJiBlcnJvci5jb2RlICE9PSAnRUNPTk5BQk9SVEVEJykpIHtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgZGVsYXlNcyA9IGluaXRpYWxEZWxheU1zICogTWF0aC5wb3coMiwgYXR0ZW1wdCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0ICR7YXR0ZW1wdCArIDF9IGZhaWxlZCwgcmV0cnlpbmcgaW4gJHtkZWxheU1zfW1zLi4uYCk7XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheU1zKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRocm93IGxhc3RFcnJvcjtcclxufTtcclxuXHJcbi8vIERlZmluZSBBUEkgZW5kcG9pbnRzXHJcbmNvbnN0IGFwaSA9IHtcclxuICAvLyBDaGVjayBBUEkgY29ubmVjdGl2aXR5IChuZXcgbWV0aG9kKVxyXG4gIGNoZWNrQmFja2VuZENvbm5lY3Rpb246IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFNpbXBsZSBlbmRwb2ludCB0aGF0IHNob3VsZCBhbHdheXMgYmUgYXZhaWxhYmxlXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldCgnL2FwaS8nKTtcclxuICAgICAgY29uc29sZS5sb2coJ0JhY2tlbmQgY29ubmVjdGlvbiBzdWNjZXNzZnVsJyk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignQmFja2VuZCBjb25uZWN0aW9uIGZhaWxlZDonLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gQXV0aCAoTm90ZTogWW91ciBhY3R1YWwgYmFja2VuZCBtYXkgaGF2ZSBkaWZmZXJlbnQgYXV0aCBlbmRwb2ludHMpXHJcbiAgbG9naW46IGFzeW5jIChjcmVkZW50aWFscykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVGhpcyBlbmRwb2ludCBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24geW91ciBhY3R1YWwgYmFja2VuZCBhdXRoIGVuZHBvaW50c1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNhbGxXaXRoUmV0cnkoKCkgPT4gYXBpQ2xpZW50LnBvc3QoJy9hcGkvdG9rZW4vJywgY3JlZGVudGlhbHMpKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gRGVwYXJ0bWVudHNcclxuICBnZXREZXBhcnRtZW50czogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIGRlcGFydG1lbnRzIGZyb206JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvZGVwYXJ0bWVudHMvYCk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeSgoKSA9PiBhcGlDbGllbnQuZ2V0KCcvYXBpL2RlcGFydG1lbnRzLycpKTtcclxuICAgICAgY29uc29sZS5sb2coJ0RlcGFydG1lbnRzIGZldGNoZWQgc3VjY2Vzc2Z1bGx5OicsIHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaWYgdGhlIGRhdGEgaXMgbnVsbCBvciB1bmRlZmluZWRcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBkZXBhcnRtZW50czonLCBlcnJvcik7XHJcbiAgICAgIC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvciB0byBwcmV2ZW50IFVJIGJyZWFraW5nXHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIEJ1c2luZXNzIFVuaXRzXHJcbiAgZ2V0QnVzaW5lc3NVbml0czogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KCcvYXBpL2J1c2luZXNzLXVuaXRzLycpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGJ1c2luZXNzIHVuaXRzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBnZXRCdXNpbmVzc1VuaXQ6IGFzeW5jIChidXNpbmVzc1VuaXRJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL2J1c2luZXNzLXVuaXRzLyR7YnVzaW5lc3NVbml0SWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGJ1c2luZXNzIHVuaXQgJHtidXNpbmVzc1VuaXRJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGNyZWF0ZUJ1c2luZXNzVW5pdDogYXN5bmMgKGJ1c2luZXNzVW5pdERhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoJy9hcGkvYnVzaW5lc3MtdW5pdHMvJywgYnVzaW5lc3NVbml0RGF0YSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgYnVzaW5lc3MgdW5pdDonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgdXBkYXRlQnVzaW5lc3NVbml0OiBhc3luYyAoYnVzaW5lc3NVbml0SWQsIGJ1c2luZXNzVW5pdERhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnB1dChgL2FwaS9idXNpbmVzcy11bml0cy8ke2J1c2luZXNzVW5pdElkfS9gLCBidXNpbmVzc1VuaXREYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1cGRhdGluZyBidXNpbmVzcyB1bml0ICR7YnVzaW5lc3NVbml0SWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBkZWxldGVCdXNpbmVzc1VuaXQ6IGFzeW5jIChidXNpbmVzc1VuaXRJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZGVsZXRlKGAvYXBpL2J1c2luZXNzLXVuaXRzLyR7YnVzaW5lc3NVbml0SWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIGJ1c2luZXNzIHVuaXQgJHtidXNpbmVzc1VuaXRJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIE9LUiBCdXNpbmVzcyBVbml0c1xyXG4gIGdldE9LUkJ1c2luZXNzVW5pdHM6IGFzeW5jIChva3JJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL29rcnMvJHtva3JJZH0vYnVzaW5lc3NfdW5pdHMvYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgYnVzaW5lc3MgdW5pdHMgZm9yIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgYXNzaWduQnVzaW5lc3NVbml0c1RvT0tSOiBhc3luYyAob2tySWQsIGJ1c2luZXNzVW5pdElkcykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdChgL2FwaS9va3JzLyR7b2tySWR9L2Fzc2lnbl9idXNpbmVzc191bml0cy9gLCBidXNpbmVzc1VuaXRJZHMpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFzc2lnbmluZyBidXNpbmVzcyB1bml0cyB0byBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIFVzZXJzXHJcbiAgZ2V0VXNlcnM6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyB1c2VycyBmcm9tOicsIGAke0FQSV9CQVNFX1VSTH0vYXBpL3VzZXJzL2ApO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNhbGxXaXRoUmV0cnkoKCkgPT4gYXBpQ2xpZW50LmdldCgnL2FwaS91c2Vycy8nKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdVc2VycyBmZXRjaGVkIHN1Y2Nlc3NmdWxseTonLCByZXNwb25zZS5kYXRhKTtcclxuICAgICAgLy8gUmV0dXJuIGVtcHR5IGFycmF5IGlmIHRoZSBkYXRhIGlzIG51bGwgb3IgdW5kZWZpbmVkXHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdXNlcnM6JywgZXJyb3IpO1xyXG4gICAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgb24gZXJyb3IgdG8gcHJldmVudCBVSSBicmVha2luZ1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBnZXRVc2VyOiBhc3luYyAodXNlcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvdXNlcnMvJHt1c2VySWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHVzZXIgJHt1c2VySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBPS1JzXHJcbiAgZ2V0T0tSczogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KCcvYXBpL29rcnMvJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgT0tSczonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgZ2V0T0tSOiBhc3luYyAob2tySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS9va3JzLyR7b2tySWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgY3JlYXRlT0tSOiBhc3luYyAob2tyRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVHJhbnNmb3JtIHRoZSBkYXRhIGZvcm1hdCB0byBtYXRjaCB3aGF0IHRoZSBiYWNrZW5kIGV4cGVjdHNcclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWREYXRhID0ge1xyXG4gICAgICAgIC4uLm9rckRhdGEsXHJcbiAgICAgICAgLy8gTWFwIHRpdGxlIHRvIG5hbWUgaWYgdGl0bGUgZXhpc3RzXHJcbiAgICAgICAgbmFtZTogb2tyRGF0YS50aXRsZSxcclxuICAgICAgICAvLyBGb3IgdXNlciBtYXBwaW5ncyAtIGNvbnZlcnQgYXNzaWduZWRfdXNlcnMgdG8gdGhlIGZvcm1hdCBiYWNrZW5kIGV4cGVjdHNcclxuICAgICAgICBhc3NpZ25lZF91c2VyX2lkczogb2tyRGF0YS5hc3NpZ25lZF91c2VyX2lkcyB8fCBbXSxcclxuICAgICAgICAvLyBTZXQgcHJpbWFyeSB1c2VyXHJcbiAgICAgICAgcHJpbWFyeV91c2VyX2lkOiBva3JEYXRhLnByaW1hcnlfdXNlcl9pZCB8fCBudWxsLFxyXG4gICAgICAgIC8vIFVzZSBidXNpbmVzc191bml0X2lkcyBpZiBpdCBleGlzdHNcclxuICAgICAgICBidXNpbmVzc191bml0X2lkczogb2tyRGF0YS5idXNpbmVzc191bml0X2lkcyB8fCBbXVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gUmVtb3ZlIHRpdGxlIGZpZWxkIGFzIHdlJ3ZlIHRyYW5zZm9ybWVkIGl0IHRvIG5hbWVcclxuICAgICAgaWYgKHRyYW5zZm9ybWVkRGF0YS50aXRsZSkge1xyXG4gICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1lZERhdGEudGl0bGU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIExvZyB0aGUgdHJhbnNmb3JtZWQgZGF0YSBiZWluZyBzZW50XHJcbiAgICAgIGNvbnNvbGUubG9nKCdEYXRhIGJlaW5nIHNlbnQgdG8gY3JlYXRlIE9LUiBBUEk6Jywge1xyXG4gICAgICAgIGVuZHBvaW50OiAnL2FwaS9va3JzLycsXHJcbiAgICAgICAgb3JpZ2luYWw6IG9rckRhdGEsXHJcbiAgICAgICAgdHJhbnNmb3JtZWQ6IHRyYW5zZm9ybWVkRGF0YVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIC8vIEhhbmRsZSB0aGUgbXVsdGktdXNlciBhc3NpZ25tZW50IGFuZCBidXNpbmVzcyB1bml0cyBpbiB0aGUgYmFja2VuZFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KCcvYXBpL29rcnMvJywgdHJhbnNmb3JtZWREYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBPS1I6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIHVwZGF0ZU9LUjogYXN5bmMgKG9rcklkLCBva3JEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9ybWF0IHRvIG1hdGNoIHdoYXQgdGhlIGJhY2tlbmQgZXhwZWN0c1xyXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZERhdGEgPSB7XHJcbiAgICAgICAgLi4ub2tyRGF0YSxcclxuICAgICAgICAvLyBGb3IgdXNlciBtYXBwaW5ncyAtIGNvbnZlcnQgYXNzaWduZWRfdXNlcnMgdG8gdGhlIGZvcm1hdCBiYWNrZW5kIGV4cGVjdHNcclxuICAgICAgICBhc3NpZ25lZF91c2VyX2lkczogb2tyRGF0YS5hc3NpZ25lZF91c2VycyA/IFxyXG4gICAgICAgICAgb2tyRGF0YS5hc3NpZ25lZF91c2Vycy5tYXAodXNlciA9PiB1c2VyLnVzZXJfaWQpIDogXHJcbiAgICAgICAgICBbXSxcclxuICAgICAgICAvLyBTZXQgcHJpbWFyeSB1c2VyXHJcbiAgICAgICAgcHJpbWFyeV91c2VyX2lkOiBva3JEYXRhLmFzc2lnbmVkX3VzZXJzID8gXHJcbiAgICAgICAgICBva3JEYXRhLmFzc2lnbmVkX3VzZXJzLmZpbmQodXNlciA9PiB1c2VyLmlzX3ByaW1hcnkpPy51c2VyX2lkIDogXHJcbiAgICAgICAgICBudWxsLFxyXG4gICAgICAgIC8vIFVzZSBidXNpbmVzc191bml0X2lkcyBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB1c2UgYnVzaW5lc3NfdW5pdHNcclxuICAgICAgICBidXNpbmVzc191bml0X2lkczogb2tyRGF0YS5idXNpbmVzc191bml0X2lkcyB8fCBva3JEYXRhLmJ1c2luZXNzX3VuaXRzIHx8IFtdXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZW1vdmUgZmllbGRzIHRoZSBiYWNrZW5kIGRvZXNuJ3QgZXhwZWN0XHJcbiAgICAgIGlmICh0cmFuc2Zvcm1lZERhdGEuYXNzaWduZWRfdXNlcnMpIHtcclxuICAgICAgICBkZWxldGUgdHJhbnNmb3JtZWREYXRhLmFzc2lnbmVkX3VzZXJzO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAodHJhbnNmb3JtZWREYXRhLmJ1c2luZXNzX3VuaXRzICYmIHRyYW5zZm9ybWVkRGF0YS5idXNpbmVzc191bml0X2lkcykge1xyXG4gICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1lZERhdGEuYnVzaW5lc3NfdW5pdHM7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIExvZyB0aGUgdHJhbnNmb3JtZWQgZGF0YSBiZWluZyBzZW50XHJcbiAgICAgIGNvbnNvbGUubG9nKCdEYXRhIGJlaW5nIHNlbnQgdG8gdXBkYXRlIE9LUiBBUEk6Jywge1xyXG4gICAgICAgIGVuZHBvaW50OiBgL2FwaS9va3JzLyR7b2tySWR9L2AsXHJcbiAgICAgICAgb3JpZ2luYWw6IG9rckRhdGEsXHJcbiAgICAgICAgdHJhbnNmb3JtZWQ6IHRyYW5zZm9ybWVkRGF0YVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucHV0KGAvYXBpL29rcnMvJHtva3JJZH0vYCwgdHJhbnNmb3JtZWREYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1cGRhdGluZyBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGRlbGV0ZU9LUjogYXN5bmMgKG9rcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvb2tycy8ke29rcklkfS9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZWxldGluZyBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIENoaWxkIE9LUnMgLSBHZXQgT0tScyB3aXRoIGEgc3BlY2lmaWMgcGFyZW50X29rclxyXG4gIGdldENoaWxkT0tSczogYXN5bmMgKHBhcmVudE9rcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvb2tycy8/cGFyZW50X29rcj0ke3BhcmVudE9rcklkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNoaWxkIE9LUnMgZm9yIHBhcmVudCAke3BhcmVudE9rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gR2V0IGFzc2lnbmVkIHVzZXJzIGZvciBhbiBPS1JcclxuICBnZXRPS1JBc3NpZ25lZFVzZXJzOiBhc3luYyAob2tySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS9va3JzLyR7b2tySWR9L2Fzc2lnbmVkX3VzZXJzL2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGFzc2lnbmVkIHVzZXJzIGZvciBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIEFkZCBhIHVzZXIgdG8gYW4gT0tSIFxyXG4gIGFkZFVzZXJUb09LUjogYXN5bmMgKG9rcklkLCB1c2VyRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdChgL2FwaS9va3JzLyR7b2tySWR9L2Fzc2lnbl91c2VyL2AsIHVzZXJEYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhZGRpbmcgdXNlciB0byBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIFJlbW92ZSBhIHVzZXIgZnJvbSBhbiBPS1JcclxuICByZW1vdmVVc2VyRnJvbU9LUjogYXN5bmMgKG9rcklkLCB1c2VySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmRlbGV0ZShgL2FwaS9va3JzLyR7b2tySWR9L3JlbW92ZV91c2VyLyR7dXNlcklkfS9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZW1vdmluZyB1c2VyIGZyb20gT0tSICR7b2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBTZXQgYSB1c2VyIGFzIHByaW1hcnkgZm9yIGFuIE9LUlxyXG4gIHNldFByaW1hcnlVc2VyRm9yT0tSOiBhc3luYyAob2tySWQsIHVzZXJJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdChgL2FwaS9va3JzLyR7b2tySWR9L3NldF9wcmltYXJ5X3VzZXIvYCwgeyB1c2VyX2lkOiB1c2VySWQgfSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2V0dGluZyBwcmltYXJ5IHVzZXIgZm9yIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVGFza3NcclxuICBnZXRUYXNrczogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KCcvYXBpL3Rhc2tzLycpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRhc2tzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBnZXRUYXNrOiBhc3luYyAodGFza0lkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvdGFza3MvJHt0YXNrSWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHRhc2sgJHt0YXNrSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBjcmVhdGVUYXNrOiBhc3luYyAodGFza0RhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoJy9hcGkvdGFza3MvJywgdGFza0RhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHRhc2s6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIHVwZGF0ZVRhc2s6IGFzeW5jICh0YXNrSWQsIHRhc2tEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQoYC9hcGkvdGFza3MvJHt0YXNrSWR9L2AsIHRhc2tEYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1cGRhdGluZyB0YXNrICR7dGFza0lkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgZGVsZXRlVGFzazogYXN5bmMgKHRhc2tJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZGVsZXRlKGAvYXBpL3Rhc2tzLyR7dGFza0lkfS9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZWxldGluZyB0YXNrICR7dGFza0lkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gT0tSIFRhc2tzIC0gR2V0IHRhc2tzIGZvciBhIHNwZWNpZmljIE9LUlxyXG4gIGdldE9LUlRhc2tzOiBhc3luYyAob2tySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS90YXNrcy8/bGlua2VkX3RvX29rcj0ke29rcklkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHRhc2tzIGZvciBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIFVzZXItc3BlY2lmaWMgT0tScyAtIG5vdyBzdXBwb3J0cyBib3RoIGFzc2lnbmVkX3RvIChsZWdhY3kpIGFuZCBva3JfdXNlcl9tYXBwaW5nc1xyXG4gIGdldFVzZXJPS1JzOiBhc3luYyAodXNlcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvb2tycy91c2VyLyR7dXNlcklkfS9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBPS1JzIGZvciB1c2VyICR7dXNlcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVXNlci1zcGVjaWZpYyB0YXNrc1xyXG4gIGdldFVzZXJUYXNrczogYXN5bmMgKHVzZXJJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL3Rhc2tzLz9hc3NpZ25lZF90bz0ke3VzZXJJZH1gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyB0YXNrcyBmb3IgdXNlciAke3VzZXJJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBUYXNrQ2hhbGxlbmdlc1xyXG4gIGdldFRhc2tDaGFsbGVuZ2VzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvdGFzay1jaGFsbGVuZ2VzLycpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRhc2sgY2hhbGxlbmdlczonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgZ2V0VGFza0NoYWxsZW5nZTogYXN5bmMgKGNoYWxsZW5nZUlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvdGFzay1jaGFsbGVuZ2VzLyR7Y2hhbGxlbmdlSWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHRhc2sgY2hhbGxlbmdlICR7Y2hhbGxlbmdlSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBjcmVhdGVUYXNrQ2hhbGxlbmdlOiBhc3luYyAoY2hhbGxlbmdlRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS90YXNrLWNoYWxsZW5nZXMvJywgY2hhbGxlbmdlRGF0YSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdGFzayBjaGFsbGVuZ2U6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIHVwZGF0ZVRhc2tDaGFsbGVuZ2U6IGFzeW5jIChjaGFsbGVuZ2VJZCwgY2hhbGxlbmdlRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucHV0KGAvYXBpL3Rhc2stY2hhbGxlbmdlcy8ke2NoYWxsZW5nZUlkfS9gLCBjaGFsbGVuZ2VEYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1cGRhdGluZyB0YXNrIGNoYWxsZW5nZSAke2NoYWxsZW5nZUlkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgZGVsZXRlVGFza0NoYWxsZW5nZTogYXN5bmMgKGNoYWxsZW5nZUlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvdGFzay1jaGFsbGVuZ2VzLyR7Y2hhbGxlbmdlSWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIHRhc2sgY2hhbGxlbmdlICR7Y2hhbGxlbmdlSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBHZXQgY2hhbGxlbmdlcyBmb3IgYSBzcGVjaWZpYyB0YXNrXHJcbiAgZ2V0VGFza0NoYWxsZW5nZXNCeVRhc2s6IGFzeW5jICh0YXNrSWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS90YXNrLWNoYWxsZW5nZXMvYnlfdGFzay8/dGFza19pZD0ke3Rhc2tJZH1gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjaGFsbGVuZ2VzIGZvciB0YXNrICR7dGFza0lkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhcGk7Il0sIm5hbWVzIjpbImF4aW9zIiwiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJhcGlDbGllbnQiLCJjcmVhdGUiLCJiYXNlVVJMIiwiaGVhZGVycyIsInRpbWVvdXQiLCJpbnRlcmNlcHRvcnMiLCJyZXF1ZXN0IiwidXNlIiwiY29uZmlnIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiY29uc29sZSIsImxvZyIsInVybCIsImVycm9yIiwiUHJvbWlzZSIsInJlamVjdCIsInJlc3BvbnNlIiwiZGF0YSIsInN0YXR1cyIsIm1lc3NhZ2UiLCJhcGlDYWxsV2l0aFJldHJ5IiwiYXBpQ2FsbCIsInJldHJ5Q291bnQiLCJpbml0aWFsRGVsYXlNcyIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJjb2RlIiwiZGVsYXlNcyIsIk1hdGgiLCJwb3ciLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImFwaSIsImNoZWNrQmFja2VuZENvbm5lY3Rpb24iLCJnZXQiLCJsb2dpbiIsImNyZWRlbnRpYWxzIiwicG9zdCIsImdldERlcGFydG1lbnRzIiwiZ2V0QnVzaW5lc3NVbml0cyIsImdldEJ1c2luZXNzVW5pdCIsImJ1c2luZXNzVW5pdElkIiwiY3JlYXRlQnVzaW5lc3NVbml0IiwiYnVzaW5lc3NVbml0RGF0YSIsInVwZGF0ZUJ1c2luZXNzVW5pdCIsInB1dCIsImRlbGV0ZUJ1c2luZXNzVW5pdCIsImRlbGV0ZSIsImdldE9LUkJ1c2luZXNzVW5pdHMiLCJva3JJZCIsImFzc2lnbkJ1c2luZXNzVW5pdHNUb09LUiIsImJ1c2luZXNzVW5pdElkcyIsImdldFVzZXJzIiwiZ2V0VXNlciIsInVzZXJJZCIsImdldE9LUnMiLCJnZXRPS1IiLCJjcmVhdGVPS1IiLCJva3JEYXRhIiwidHJhbnNmb3JtZWREYXRhIiwibmFtZSIsInRpdGxlIiwiYXNzaWduZWRfdXNlcl9pZHMiLCJwcmltYXJ5X3VzZXJfaWQiLCJidXNpbmVzc191bml0X2lkcyIsImVuZHBvaW50Iiwib3JpZ2luYWwiLCJ0cmFuc2Zvcm1lZCIsInVwZGF0ZU9LUiIsImFzc2lnbmVkX3VzZXJzIiwibWFwIiwidXNlciIsInVzZXJfaWQiLCJmaW5kIiwiaXNfcHJpbWFyeSIsImJ1c2luZXNzX3VuaXRzIiwiZGVsZXRlT0tSIiwiZ2V0Q2hpbGRPS1JzIiwicGFyZW50T2tySWQiLCJnZXRPS1JBc3NpZ25lZFVzZXJzIiwiYWRkVXNlclRvT0tSIiwidXNlckRhdGEiLCJyZW1vdmVVc2VyRnJvbU9LUiIsInNldFByaW1hcnlVc2VyRm9yT0tSIiwiZ2V0VGFza3MiLCJnZXRUYXNrIiwidGFza0lkIiwiY3JlYXRlVGFzayIsInRhc2tEYXRhIiwidXBkYXRlVGFzayIsImRlbGV0ZVRhc2siLCJnZXRPS1JUYXNrcyIsImdldFVzZXJPS1JzIiwiZ2V0VXNlclRhc2tzIiwiZ2V0VGFza0NoYWxsZW5nZXMiLCJnZXRUYXNrQ2hhbGxlbmdlIiwiY2hhbGxlbmdlSWQiLCJjcmVhdGVUYXNrQ2hhbGxlbmdlIiwiY2hhbGxlbmdlRGF0YSIsInVwZGF0ZVRhc2tDaGFsbGVuZ2UiLCJkZWxldGVUYXNrQ2hhbGxlbmdlIiwiZ2V0VGFza0NoYWxsZW5nZXNCeVRhc2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/api.js\n"));

/***/ })

});