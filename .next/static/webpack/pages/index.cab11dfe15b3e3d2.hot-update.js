"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./lib/api.js":
/*!********************!*\
  !*** ./lib/api.js ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n// Define API base URL\n// In a real app, this would be read from environment variables\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000\";\n// Create axios instance with default config\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    // Add longer timeout to handle potential network delays\n    timeout: 15000\n});\n// Add request interceptor to attach auth token\napiClient.interceptors.request.use((config)=>{\n    // Skip authentication for local development if needed\n    if (true) {\n        const token = localStorage.getItem(\"auth_token\");\n        if (token) {\n            config.headers[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n    }\n    console.log(\"Making request to: \".concat(config.baseURL).concat(config.url));\n    return config;\n}, (error)=>Promise.reject(error));\n// Add response interceptor for better error handling\napiClient.interceptors.response.use((response)=>response, (error)=>{\n    // Log better error information\n    if (error.response) {\n        var _error_config;\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        console.error(\"API Error Response:\", {\n            data: error.response.data,\n            status: error.response.status,\n            headers: error.response.headers,\n            url: (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url\n        });\n    } else if (error.request) {\n        var _error_config1, _error_config2;\n        // The request was made but no response was received\n        console.error(\"API No Response:\", {\n            request: error.request,\n            message: \"No response received from server. Is the backend running?\",\n            url: (_error_config1 = error.config) === null || _error_config1 === void 0 ? void 0 : _error_config1.url,\n            baseURL: (_error_config2 = error.config) === null || _error_config2 === void 0 ? void 0 : _error_config2.baseURL\n        });\n        console.log(\"Backend connectivity issue. Make sure Django server is running at:\", API_BASE_URL);\n    } else {\n        // Something happened in setting up the request that triggered an Error\n        console.error(\"API Request Error:\", error.message);\n    }\n    return Promise.reject(error);\n});\n// Helper function for retry logic\nconst apiCallWithRetry = async function(apiCall) {\n    let retryCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, initialDelayMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1000;\n    let lastError;\n    for(let attempt = 0; attempt < retryCount; attempt++){\n        try {\n            return await apiCall();\n        } catch (error) {\n            lastError = error;\n            // Only retry network or timeout errors\n            if (!error.code || error.code !== \"ERR_NETWORK\" && error.code !== \"ECONNABORTED\") {\n                throw error;\n            }\n            const delayMs = initialDelayMs * Math.pow(2, attempt);\n            console.log(\"Attempt \".concat(attempt + 1, \" failed, retrying in \").concat(delayMs, \"ms...\"));\n            await new Promise((resolve)=>setTimeout(resolve, delayMs));\n        }\n    }\n    throw lastError;\n};\n// Define API endpoints\nconst api = {\n    // Check API connectivity (new method)\n    checkBackendConnection: async ()=>{\n        try {\n            // Simple endpoint that should always be available\n            const response = await apiClient.get(\"/api/\");\n            console.log(\"Backend connection successful\");\n            return true;\n        } catch (error) {\n            console.error(\"Backend connection failed:\", error.message);\n            return false;\n        }\n    },\n    // Auth (Note: Your actual backend may have different auth endpoints)\n    login: async (credentials)=>{\n        try {\n            // This endpoint might need to be updated based on your actual backend auth endpoints\n            const response = await apiCallWithRetry(()=>apiClient.post(\"/api/token/\", credentials));\n            return response.data;\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        }\n    },\n    // Departments\n    getDepartments: async ()=>{\n        try {\n            console.log(\"Fetching departments from:\", \"\".concat(API_BASE_URL, \"/api/departments/\"));\n            const response = await apiCallWithRetry(()=>apiClient.get(\"/api/departments/\"));\n            console.log(\"Departments fetched successfully:\", response.data);\n            // Return empty array if the data is null or undefined\n            return response.data || [];\n        } catch (error) {\n            console.error(\"Error fetching departments:\", error);\n            // Return empty array on error to prevent UI breaking\n            return [];\n        }\n    },\n    // Business Units\n    getBusinessUnits: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/business-units/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business units:\", error);\n            throw error;\n        }\n    },\n    getBusinessUnit: async (businessUnitId)=>{\n        try {\n            const response = await apiClient.get(\"/api/business-units/\".concat(businessUnitId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    createBusinessUnit: async (businessUnitData)=>{\n        try {\n            const response = await apiClient.post(\"/api/business-units/\", businessUnitData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating business unit:\", error);\n            throw error;\n        }\n    },\n    updateBusinessUnit: async (businessUnitId, businessUnitData)=>{\n        try {\n            const response = await apiClient.put(\"/api/business-units/\".concat(businessUnitId, \"/\"), businessUnitData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteBusinessUnit: async (businessUnitId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/business-units/\".concat(businessUnitId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting business unit \".concat(businessUnitId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKR Business Units\n    getOKRBusinessUnits: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/business_units/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching business units for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    assignBusinessUnitsToOKR: async (okrId, businessUnitIds)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/assign_business_units/\"), businessUnitIds);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error assigning business units to OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Users\n    getUsers: async ()=>{\n        try {\n            console.log(\"Fetching users from:\", \"\".concat(API_BASE_URL, \"/api/users/\"));\n            const response = await apiCallWithRetry(()=>apiClient.get(\"/api/users/\"));\n            console.log(\"Users fetched successfully:\", response.data);\n            // Return empty array if the data is null or undefined\n            return response.data || [];\n        } catch (error) {\n            console.error(\"Error fetching users:\", error);\n            // Return empty array on error to prevent UI breaking\n            return [];\n        }\n    },\n    getUser: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/users/\".concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKRs\n    getOKRs: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKRs:\", error);\n            throw error;\n        }\n    },\n    getOKR: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    createOKR: async (okrData)=>{\n        try {\n            // Handle the multi-user assignment and business units in the backend\n            const response = await apiClient.post(\"/api/okrs/\", okrData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating OKR:\", error);\n            throw error;\n        }\n    },\n    updateOKR: async (okrId, okrData)=>{\n        try {\n            var _okrData_assigned_users_find;\n            // Transform the data format to match what the backend expects\n            const transformedData = {\n                ...okrData,\n                // For user mappings - convert assigned_users to the format backend expects\n                assigned_user_ids: okrData.assigned_users ? okrData.assigned_users.map((user)=>user.user_id) : [],\n                // Set primary user\n                primary_user_id: okrData.assigned_users ? (_okrData_assigned_users_find = okrData.assigned_users.find((user)=>user.is_primary)) === null || _okrData_assigned_users_find === void 0 ? void 0 : _okrData_assigned_users_find.user_id : null,\n                // Use business_unit_ids if it exists, otherwise use business_units\n                business_unit_ids: okrData.business_unit_ids || okrData.business_units || []\n            };\n            // Remove fields the backend doesn't expect\n            if (transformedData.assigned_users) {\n                delete transformedData.assigned_users;\n            }\n            if (transformedData.business_units && transformedData.business_unit_ids) {\n                delete transformedData.business_units;\n            }\n            // Log the transformed data being sent\n            console.log(\"Data being sent to update OKR API:\", {\n                endpoint: \"/api/okrs/\".concat(okrId, \"/\"),\n                original: okrData,\n                transformed: transformedData\n            });\n            // Send the request\n            const response = await apiClient.put(\"/api/okrs/\".concat(okrId, \"/\"), transformedData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteOKR: async (okrId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/okrs/\".concat(okrId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Child OKRs - Get OKRs with a specific parent_okr\n    getChildOKRs: async (parentOkrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/?parent_okr=\".concat(parentOkrId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching child OKRs for parent \".concat(parentOkrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Get assigned users for an OKR\n    getOKRAssignedUsers: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/\".concat(okrId, \"/assigned_users/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching assigned users for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Add a user to an OKR \n    addUserToOKR: async (okrId, userData)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/assign_user/\"), userData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error adding user to OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Remove a user from an OKR\n    removeUserFromOKR: async (okrId, userId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/okrs/\".concat(okrId, \"/remove_user/\").concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error removing user from OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Set a user as primary for an OKR\n    setPrimaryUserForOKR: async (okrId, userId)=>{\n        try {\n            const response = await apiClient.post(\"/api/okrs/\".concat(okrId, \"/set_primary_user/\"), {\n                user_id: userId\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error setting primary user for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // Tasks\n    getTasks: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks:\", error);\n            throw error;\n        }\n    },\n    getTask: async (taskId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/\".concat(taskId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    createTask: async (taskData)=>{\n        try {\n            const response = await apiClient.post(\"/api/tasks/\", taskData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating task:\", error);\n            throw error;\n        }\n    },\n    updateTask: async (taskId, taskData)=>{\n        try {\n            const response = await apiClient.put(\"/api/tasks/\".concat(taskId, \"/\"), taskData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteTask: async (taskId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/tasks/\".concat(taskId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    },\n    // OKR Tasks - Get tasks for a specific OKR\n    getOKRTasks: async (okrId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/?linked_to_okr=\".concat(okrId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks for OKR \".concat(okrId, \":\"), error);\n            throw error;\n        }\n    },\n    // User-specific OKRs - now supports both assigned_to (legacy) and okr_user_mappings\n    getUserOKRs: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/okrs/user/\".concat(userId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching OKRs for user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // User-specific tasks\n    getUserTasks: async (userId)=>{\n        try {\n            const response = await apiClient.get(\"/api/tasks/?assigned_to=\".concat(userId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tasks for user \".concat(userId, \":\"), error);\n            throw error;\n        }\n    },\n    // TaskChallenges\n    getTaskChallenges: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task challenges:\", error);\n            throw error;\n        }\n    },\n    getTaskChallenge: async (challengeId)=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/\".concat(challengeId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    createTaskChallenge: async (challengeData)=>{\n        try {\n            const response = await apiClient.post(\"/api/task-challenges/\", challengeData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating task challenge:\", error);\n            throw error;\n        }\n    },\n    updateTaskChallenge: async (challengeId, challengeData)=>{\n        try {\n            const response = await apiClient.put(\"/api/task-challenges/\".concat(challengeId, \"/\"), challengeData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    deleteTaskChallenge: async (challengeId)=>{\n        try {\n            const response = await apiClient.delete(\"/api/task-challenges/\".concat(challengeId, \"/\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error deleting task challenge \".concat(challengeId, \":\"), error);\n            throw error;\n        }\n    },\n    // Get challenges for a specific task\n    getTaskChallengesByTask: async (taskId)=>{\n        try {\n            const response = await apiClient.get(\"/api/task-challenges/by_task/?task_id=\".concat(taskId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching challenges for task \".concat(taskId, \":\"), error);\n            throw error;\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UjtJQUNGO0lBRUEscUNBQXFDO0lBQ3JDc0YseUJBQXlCLE9BQU9mO1FBQzlCLElBQUk7WUFDRixNQUFNcEUsV0FBVyxNQUFNbEIsVUFBVW9DLEdBQUcsQ0FBQyx5Q0FBZ0QsT0FBUGtEO1lBQzlFLE9BQU9wRSxTQUFTQyxJQUFJO1FBQ3RCLEVBQUUsT0FBT0osT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsc0NBQTZDLE9BQVB1RSxRQUFPLE1BQUl2RTtZQUMvRCxNQUFNQTtRQUNSO0lBQ0Y7QUFDRjtBQUVBLCtEQUFlbUIsR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpLmpzPzQ1NDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuXHJcbi8vIERlZmluZSBBUEkgYmFzZSBVUkxcclxuLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSByZWFkIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCc7XHJcblxyXG4vLyBDcmVhdGUgYXhpb3MgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IGNvbmZpZ1xyXG5jb25zdCBhcGlDbGllbnQgPSBheGlvcy5jcmVhdGUoe1xyXG4gIGJhc2VVUkw6IEFQSV9CQVNFX1VSTCxcclxuICBoZWFkZXJzOiB7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gIH0sXHJcbiAgLy8gQWRkIGxvbmdlciB0aW1lb3V0IHRvIGhhbmRsZSBwb3RlbnRpYWwgbmV0d29yayBkZWxheXNcclxuICB0aW1lb3V0OiAxNTAwMCxcclxufSk7XHJcblxyXG4vLyBBZGQgcmVxdWVzdCBpbnRlcmNlcHRvciB0byBhdHRhY2ggYXV0aCB0b2tlblxyXG5hcGlDbGllbnQuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKFxyXG4gIChjb25maWcpID0+IHtcclxuICAgIC8vIFNraXAgYXV0aGVudGljYXRpb24gZm9yIGxvY2FsIGRldmVsb3BtZW50IGlmIG5lZWRlZFxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhfdG9rZW4nKTtcclxuICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgY29uZmlnLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhgTWFraW5nIHJlcXVlc3QgdG86ICR7Y29uZmlnLmJhc2VVUkx9JHtjb25maWcudXJsfWApO1xyXG4gICAgcmV0dXJuIGNvbmZpZztcclxuICB9LFxyXG4gIChlcnJvcikgPT4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXHJcbik7XHJcblxyXG4vLyBBZGQgcmVzcG9uc2UgaW50ZXJjZXB0b3IgZm9yIGJldHRlciBlcnJvciBoYW5kbGluZ1xyXG5hcGlDbGllbnQuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcclxuICAocmVzcG9uc2UpID0+IHJlc3BvbnNlLFxyXG4gIChlcnJvcikgPT4ge1xyXG4gICAgLy8gTG9nIGJldHRlciBlcnJvciBpbmZvcm1hdGlvblxyXG4gICAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XHJcbiAgICAgIC8vIFRoZSByZXF1ZXN0IHdhcyBtYWRlIGFuZCB0aGUgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGEgc3RhdHVzIGNvZGVcclxuICAgICAgLy8gdGhhdCBmYWxscyBvdXQgb2YgdGhlIHJhbmdlIG9mIDJ4eFxyXG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3IgUmVzcG9uc2U6Jywge1xyXG4gICAgICAgIGRhdGE6IGVycm9yLnJlc3BvbnNlLmRhdGEsXHJcbiAgICAgICAgc3RhdHVzOiBlcnJvci5yZXNwb25zZS5zdGF0dXMsXHJcbiAgICAgICAgaGVhZGVyczogZXJyb3IucmVzcG9uc2UuaGVhZGVycyxcclxuICAgICAgICB1cmw6IGVycm9yLmNvbmZpZz8udXJsLFxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAoZXJyb3IucmVxdWVzdCkge1xyXG4gICAgICAvLyBUaGUgcmVxdWVzdCB3YXMgbWFkZSBidXQgbm8gcmVzcG9uc2Ugd2FzIHJlY2VpdmVkXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBObyBSZXNwb25zZTonLCB7XHJcbiAgICAgICAgcmVxdWVzdDogZXJyb3IucmVxdWVzdCxcclxuICAgICAgICBtZXNzYWdlOiAnTm8gcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXIuIElzIHRoZSBiYWNrZW5kIHJ1bm5pbmc/JyxcclxuICAgICAgICB1cmw6IGVycm9yLmNvbmZpZz8udXJsLFxyXG4gICAgICAgIGJhc2VVUkw6IGVycm9yLmNvbmZpZz8uYmFzZVVSTCxcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdCYWNrZW5kIGNvbm5lY3Rpdml0eSBpc3N1ZS4gTWFrZSBzdXJlIERqYW5nbyBzZXJ2ZXIgaXMgcnVubmluZyBhdDonLCBBUElfQkFTRV9VUkwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gU29tZXRoaW5nIGhhcHBlbmVkIGluIHNldHRpbmcgdXAgdGhlIHJlcXVlc3QgdGhhdCB0cmlnZ2VyZWQgYW4gRXJyb3JcclxuICAgICAgY29uc29sZS5lcnJvcignQVBJIFJlcXVlc3QgRXJyb3I6JywgZXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gIH1cclxuKTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiBmb3IgcmV0cnkgbG9naWNcclxuY29uc3QgYXBpQ2FsbFdpdGhSZXRyeSA9IGFzeW5jIChhcGlDYWxsLCByZXRyeUNvdW50ID0gMywgaW5pdGlhbERlbGF5TXMgPSAxMDAwKSA9PiB7XHJcbiAgbGV0IGxhc3RFcnJvcjtcclxuICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IHJldHJ5Q291bnQ7IGF0dGVtcHQrKykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIGF3YWl0IGFwaUNhbGwoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xyXG4gICAgICAvLyBPbmx5IHJldHJ5IG5ldHdvcmsgb3IgdGltZW91dCBlcnJvcnNcclxuICAgICAgaWYgKCFlcnJvci5jb2RlIHx8IChlcnJvci5jb2RlICE9PSAnRVJSX05FVFdPUksnICYmIGVycm9yLmNvZGUgIT09ICdFQ09OTkFCT1JURUQnKSkge1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBkZWxheU1zID0gaW5pdGlhbERlbGF5TXMgKiBNYXRoLnBvdygyLCBhdHRlbXB0KTtcclxuICAgICAgY29uc29sZS5sb2coYEF0dGVtcHQgJHthdHRlbXB0ICsgMX0gZmFpbGVkLCByZXRyeWluZyBpbiAke2RlbGF5TXN9bXMuLi5gKTtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5TXMpKTtcclxuICAgIH1cclxuICB9XHJcbiAgdGhyb3cgbGFzdEVycm9yO1xyXG59O1xyXG5cclxuLy8gRGVmaW5lIEFQSSBlbmRwb2ludHNcclxuY29uc3QgYXBpID0ge1xyXG4gIC8vIENoZWNrIEFQSSBjb25uZWN0aXZpdHkgKG5ldyBtZXRob2QpXHJcbiAgY2hlY2tCYWNrZW5kQ29ubmVjdGlvbjogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU2ltcGxlIGVuZHBvaW50IHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBhdmFpbGFibGVcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KCcvYXBpLycpO1xyXG4gICAgICBjb25zb2xlLmxvZygnQmFja2VuZCBjb25uZWN0aW9uIHN1Y2Nlc3NmdWwnKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdCYWNrZW5kIGNvbm5lY3Rpb24gZmFpbGVkOicsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBBdXRoIChOb3RlOiBZb3VyIGFjdHVhbCBiYWNrZW5kIG1heSBoYXZlIGRpZmZlcmVudCBhdXRoIGVuZHBvaW50cylcclxuICBsb2dpbjogYXN5bmMgKGNyZWRlbnRpYWxzKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBUaGlzIGVuZHBvaW50IG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiB5b3VyIGFjdHVhbCBiYWNrZW5kIGF1dGggZW5kcG9pbnRzXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeSgoKSA9PiBhcGlDbGllbnQucG9zdCgnL2FwaS90b2tlbi8nLCBjcmVkZW50aWFscykpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ2luIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBEZXBhcnRtZW50c1xyXG4gIGdldERlcGFydG1lbnRzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgZGVwYXJ0bWVudHMgZnJvbTonLCBgJHtBUElfQkFTRV9VUkx9L2FwaS9kZXBhcnRtZW50cy9gKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsV2l0aFJldHJ5KCgpID0+IGFwaUNsaWVudC5nZXQoJy9hcGkvZGVwYXJ0bWVudHMvJykpO1xyXG4gICAgICBjb25zb2xlLmxvZygnRGVwYXJ0bWVudHMgZmV0Y2hlZCBzdWNjZXNzZnVsbHk6JywgcmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgIC8vIFJldHVybiBlbXB0eSBhcnJheSBpZiB0aGUgZGF0YSBpcyBudWxsIG9yIHVuZGVmaW5lZFxyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YSB8fCBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRlcGFydG1lbnRzOicsIGVycm9yKTtcclxuICAgICAgLy8gUmV0dXJuIGVtcHR5IGFycmF5IG9uIGVycm9yIHRvIHByZXZlbnQgVUkgYnJlYWtpbmdcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gQnVzaW5lc3MgVW5pdHNcclxuICBnZXRCdXNpbmVzc1VuaXRzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvYnVzaW5lc3MtdW5pdHMvJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYnVzaW5lc3MgdW5pdHM6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGdldEJ1c2luZXNzVW5pdDogYXN5bmMgKGJ1c2luZXNzVW5pdElkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvYnVzaW5lc3MtdW5pdHMvJHtidXNpbmVzc1VuaXRJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgYnVzaW5lc3MgdW5pdCAke2J1c2luZXNzVW5pdElkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgY3JlYXRlQnVzaW5lc3NVbml0OiBhc3luYyAoYnVzaW5lc3NVbml0RGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS9idXNpbmVzcy11bml0cy8nLCBidXNpbmVzc1VuaXREYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBidXNpbmVzcyB1bml0OicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICB1cGRhdGVCdXNpbmVzc1VuaXQ6IGFzeW5jIChidXNpbmVzc1VuaXRJZCwgYnVzaW5lc3NVbml0RGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucHV0KGAvYXBpL2J1c2luZXNzLXVuaXRzLyR7YnVzaW5lc3NVbml0SWR9L2AsIGJ1c2luZXNzVW5pdERhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIGJ1c2luZXNzIHVuaXQgJHtidXNpbmVzc1VuaXRJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGRlbGV0ZUJ1c2luZXNzVW5pdDogYXN5bmMgKGJ1c2luZXNzVW5pdElkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvYnVzaW5lc3MtdW5pdHMvJHtidXNpbmVzc1VuaXRJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgYnVzaW5lc3MgdW5pdCAke2J1c2luZXNzVW5pdElkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gT0tSIEJ1c2luZXNzIFVuaXRzXHJcbiAgZ2V0T0tSQnVzaW5lc3NVbml0czogYXN5bmMgKG9rcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvb2tycy8ke29rcklkfS9idXNpbmVzc191bml0cy9gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBidXNpbmVzcyB1bml0cyBmb3IgT0tSICR7b2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBhc3NpZ25CdXNpbmVzc1VuaXRzVG9PS1I6IGFzeW5jIChva3JJZCwgYnVzaW5lc3NVbml0SWRzKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvYXBpL29rcnMvJHtva3JJZH0vYXNzaWduX2J1c2luZXNzX3VuaXRzL2AsIGJ1c2luZXNzVW5pdElkcyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYXNzaWduaW5nIGJ1c2luZXNzIHVuaXRzIHRvIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVXNlcnNcclxuICBnZXRVc2VyczogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHVzZXJzIGZyb206JywgYCR7QVBJX0JBU0VfVVJMfS9hcGkvdXNlcnMvYCk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeSgoKSA9PiBhcGlDbGllbnQuZ2V0KCcvYXBpL3VzZXJzLycpKTtcclxuICAgICAgY29uc29sZS5sb2coJ1VzZXJzIGZldGNoZWQgc3VjY2Vzc2Z1bGx5OicsIHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaWYgdGhlIGRhdGEgaXMgbnVsbCBvciB1bmRlZmluZWRcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB1c2VyczonLCBlcnJvcik7XHJcbiAgICAgIC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvciB0byBwcmV2ZW50IFVJIGJyZWFraW5nXHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGdldFVzZXI6IGFzeW5jICh1c2VySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS91c2Vycy8ke3VzZXJJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgdXNlciAke3VzZXJJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIE9LUnNcclxuICBnZXRPS1JzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvb2tycy8nKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBPS1JzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBnZXRPS1I6IGFzeW5jIChva3JJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL29rcnMvJHtva3JJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgT0tSICR7b2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBjcmVhdGVPS1I6IGFzeW5jIChva3JEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBIYW5kbGUgdGhlIG11bHRpLXVzZXIgYXNzaWdubWVudCBhbmQgYnVzaW5lc3MgdW5pdHMgaW4gdGhlIGJhY2tlbmRcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS9va3JzLycsIG9rckRhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIE9LUjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgdXBkYXRlT0tSOiBhc3luYyAob2tySWQsIG9rckRhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3JtYXQgdG8gbWF0Y2ggd2hhdCB0aGUgYmFja2VuZCBleHBlY3RzXHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkRGF0YSA9IHtcclxuICAgICAgICAuLi5va3JEYXRhLFxyXG4gICAgICAgIC8vIEZvciB1c2VyIG1hcHBpbmdzIC0gY29udmVydCBhc3NpZ25lZF91c2VycyB0byB0aGUgZm9ybWF0IGJhY2tlbmQgZXhwZWN0c1xyXG4gICAgICAgIGFzc2lnbmVkX3VzZXJfaWRzOiBva3JEYXRhLmFzc2lnbmVkX3VzZXJzID8gXHJcbiAgICAgICAgICBva3JEYXRhLmFzc2lnbmVkX3VzZXJzLm1hcCh1c2VyID0+IHVzZXIudXNlcl9pZCkgOiBcclxuICAgICAgICAgIFtdLFxyXG4gICAgICAgIC8vIFNldCBwcmltYXJ5IHVzZXJcclxuICAgICAgICBwcmltYXJ5X3VzZXJfaWQ6IG9rckRhdGEuYXNzaWduZWRfdXNlcnMgPyBcclxuICAgICAgICAgIG9rckRhdGEuYXNzaWduZWRfdXNlcnMuZmluZCh1c2VyID0+IHVzZXIuaXNfcHJpbWFyeSk/LnVzZXJfaWQgOiBcclxuICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgLy8gVXNlIGJ1c2luZXNzX3VuaXRfaWRzIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHVzZSBidXNpbmVzc191bml0c1xyXG4gICAgICAgIGJ1c2luZXNzX3VuaXRfaWRzOiBva3JEYXRhLmJ1c2luZXNzX3VuaXRfaWRzIHx8IG9rckRhdGEuYnVzaW5lc3NfdW5pdHMgfHwgW11cclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIFJlbW92ZSBmaWVsZHMgdGhlIGJhY2tlbmQgZG9lc24ndCBleHBlY3RcclxuICAgICAgaWYgKHRyYW5zZm9ybWVkRGF0YS5hc3NpZ25lZF91c2Vycykge1xyXG4gICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1lZERhdGEuYXNzaWduZWRfdXNlcnM7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmICh0cmFuc2Zvcm1lZERhdGEuYnVzaW5lc3NfdW5pdHMgJiYgdHJhbnNmb3JtZWREYXRhLmJ1c2luZXNzX3VuaXRfaWRzKSB7XHJcbiAgICAgICAgZGVsZXRlIHRyYW5zZm9ybWVkRGF0YS5idXNpbmVzc191bml0cztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gTG9nIHRoZSB0cmFuc2Zvcm1lZCBkYXRhIGJlaW5nIHNlbnRcclxuICAgICAgY29uc29sZS5sb2coJ0RhdGEgYmVpbmcgc2VudCB0byB1cGRhdGUgT0tSIEFQSTonLCB7XHJcbiAgICAgICAgZW5kcG9pbnQ6IGAvYXBpL29rcnMvJHtva3JJZH0vYCxcclxuICAgICAgICBvcmlnaW5hbDogb2tyRGF0YSxcclxuICAgICAgICB0cmFuc2Zvcm1lZDogdHJhbnNmb3JtZWREYXRhXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQoYC9hcGkvb2tycy8ke29rcklkfS9gLCB0cmFuc2Zvcm1lZERhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgZGVsZXRlT0tSOiBhc3luYyAob2tySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmRlbGV0ZShgL2FwaS9va3JzLyR7b2tySWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gQ2hpbGQgT0tScyAtIEdldCBPS1JzIHdpdGggYSBzcGVjaWZpYyBwYXJlbnRfb2tyXHJcbiAgZ2V0Q2hpbGRPS1JzOiBhc3luYyAocGFyZW50T2tySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS9va3JzLz9wYXJlbnRfb2tyPSR7cGFyZW50T2tySWR9YCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgY2hpbGQgT0tScyBmb3IgcGFyZW50ICR7cGFyZW50T2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBHZXQgYXNzaWduZWQgdXNlcnMgZm9yIGFuIE9LUlxyXG4gIGdldE9LUkFzc2lnbmVkVXNlcnM6IGFzeW5jIChva3JJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL29rcnMvJHtva3JJZH0vYXNzaWduZWRfdXNlcnMvYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgYXNzaWduZWQgdXNlcnMgZm9yIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gQWRkIGEgdXNlciB0byBhbiBPS1IgXHJcbiAgYWRkVXNlclRvT0tSOiBhc3luYyAob2tySWQsIHVzZXJEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvYXBpL29rcnMvJHtva3JJZH0vYXNzaWduX3VzZXIvYCwgdXNlckRhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFkZGluZyB1c2VyIHRvIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gUmVtb3ZlIGEgdXNlciBmcm9tIGFuIE9LUlxyXG4gIHJlbW92ZVVzZXJGcm9tT0tSOiBhc3luYyAob2tySWQsIHVzZXJJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZGVsZXRlKGAvYXBpL29rcnMvJHtva3JJZH0vcmVtb3ZlX3VzZXIvJHt1c2VySWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlbW92aW5nIHVzZXIgZnJvbSBPS1IgJHtva3JJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIFNldCBhIHVzZXIgYXMgcHJpbWFyeSBmb3IgYW4gT0tSXHJcbiAgc2V0UHJpbWFyeVVzZXJGb3JPS1I6IGFzeW5jIChva3JJZCwgdXNlcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvYXBpL29rcnMvJHtva3JJZH0vc2V0X3ByaW1hcnlfdXNlci9gLCB7IHVzZXJfaWQ6IHVzZXJJZCB9KTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzZXR0aW5nIHByaW1hcnkgdXNlciBmb3IgT0tSICR7b2tySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBUYXNrc1xyXG4gIGdldFRhc2tzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoJy9hcGkvdGFza3MvJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGFza3M6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGdldFRhc2s6IGFzeW5jICh0YXNrSWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS90YXNrcy8ke3Rhc2tJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgdGFzayAke3Rhc2tJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGNyZWF0ZVRhc2s6IGFzeW5jICh0YXNrRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdCgnL2FwaS90YXNrcy8nLCB0YXNrRGF0YSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgdXBkYXRlVGFzazogYXN5bmMgKHRhc2tJZCwgdGFza0RhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnB1dChgL2FwaS90YXNrcy8ke3Rhc2tJZH0vYCwgdGFza0RhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIHRhc2sgJHt0YXNrSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBkZWxldGVUYXNrOiBhc3luYyAodGFza0lkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvdGFza3MvJHt0YXNrSWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIHRhc2sgJHt0YXNrSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBPS1IgVGFza3MgLSBHZXQgdGFza3MgZm9yIGEgc3BlY2lmaWMgT0tSXHJcbiAgZ2V0T0tSVGFza3M6IGFzeW5jIChva3JJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL3Rhc2tzLz9saW5rZWRfdG9fb2tyPSR7b2tySWR9YCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgdGFza3MgZm9yIE9LUiAke29rcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVXNlci1zcGVjaWZpYyBPS1JzIC0gbm93IHN1cHBvcnRzIGJvdGggYXNzaWduZWRfdG8gKGxlZ2FjeSkgYW5kIG9rcl91c2VyX21hcHBpbmdzXHJcbiAgZ2V0VXNlck9LUnM6IGFzeW5jICh1c2VySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS9va3JzL3VzZXIvJHt1c2VySWR9L2ApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIE9LUnMgZm9yIHVzZXIgJHt1c2VySWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBVc2VyLXNwZWNpZmljIHRhc2tzXHJcbiAgZ2V0VXNlclRhc2tzOiBhc3luYyAodXNlcklkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvdGFza3MvP2Fzc2lnbmVkX3RvPSR7dXNlcklkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHRhc2tzIGZvciB1c2VyICR7dXNlcklkfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIFRhc2tDaGFsbGVuZ2VzXHJcbiAgZ2V0VGFza0NoYWxsZW5nZXM6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldCgnL2FwaS90YXNrLWNoYWxsZW5nZXMvJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGFzayBjaGFsbGVuZ2VzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBnZXRUYXNrQ2hhbGxlbmdlOiBhc3luYyAoY2hhbGxlbmdlSWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS90YXNrLWNoYWxsZW5nZXMvJHtjaGFsbGVuZ2VJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgdGFzayBjaGFsbGVuZ2UgJHtjaGFsbGVuZ2VJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIGNyZWF0ZVRhc2tDaGFsbGVuZ2U6IGFzeW5jIChjaGFsbGVuZ2VEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KCcvYXBpL3Rhc2stY2hhbGxlbmdlcy8nLCBjaGFsbGVuZ2VEYXRhKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyB0YXNrIGNoYWxsZW5nZTonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgdXBkYXRlVGFza0NoYWxsZW5nZTogYXN5bmMgKGNoYWxsZW5nZUlkLCBjaGFsbGVuZ2VEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQoYC9hcGkvdGFzay1jaGFsbGVuZ2VzLyR7Y2hhbGxlbmdlSWR9L2AsIGNoYWxsZW5nZURhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIHRhc2sgY2hhbGxlbmdlICR7Y2hhbGxlbmdlSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICBkZWxldGVUYXNrQ2hhbGxlbmdlOiBhc3luYyAoY2hhbGxlbmdlSWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmRlbGV0ZShgL2FwaS90YXNrLWNoYWxsZW5nZXMvJHtjaGFsbGVuZ2VJZH0vYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgdGFzayBjaGFsbGVuZ2UgJHtjaGFsbGVuZ2VJZH06YCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIEdldCBjaGFsbGVuZ2VzIGZvciBhIHNwZWNpZmljIHRhc2tcclxuICBnZXRUYXNrQ2hhbGxlbmdlc0J5VGFzazogYXN5bmMgKHRhc2tJZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvYXBpL3Rhc2stY2hhbGxlbmdlcy9ieV90YXNrLz90YXNrX2lkPSR7dGFza0lkfWApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNoYWxsZW5nZXMgZm9yIHRhc2sgJHt0YXNrSWR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFwaTsiXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImFwaUNsaWVudCIsImNyZWF0ZSIsImJhc2VVUkwiLCJoZWFkZXJzIiwidGltZW91dCIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJjb25zb2xlIiwibG9nIiwidXJsIiwiZXJyb3IiLCJQcm9taXNlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJkYXRhIiwic3RhdHVzIiwibWVzc2FnZSIsImFwaUNhbGxXaXRoUmV0cnkiLCJhcGlDYWxsIiwicmV0cnlDb3VudCIsImluaXRpYWxEZWxheU1zIiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsImNvZGUiLCJkZWxheU1zIiwiTWF0aCIsInBvdyIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiYXBpIiwiY2hlY2tCYWNrZW5kQ29ubmVjdGlvbiIsImdldCIsImxvZ2luIiwiY3JlZGVudGlhbHMiLCJwb3N0IiwiZ2V0RGVwYXJ0bWVudHMiLCJnZXRCdXNpbmVzc1VuaXRzIiwiZ2V0QnVzaW5lc3NVbml0IiwiYnVzaW5lc3NVbml0SWQiLCJjcmVhdGVCdXNpbmVzc1VuaXQiLCJidXNpbmVzc1VuaXREYXRhIiwidXBkYXRlQnVzaW5lc3NVbml0IiwicHV0IiwiZGVsZXRlQnVzaW5lc3NVbml0IiwiZGVsZXRlIiwiZ2V0T0tSQnVzaW5lc3NVbml0cyIsIm9rcklkIiwiYXNzaWduQnVzaW5lc3NVbml0c1RvT0tSIiwiYnVzaW5lc3NVbml0SWRzIiwiZ2V0VXNlcnMiLCJnZXRVc2VyIiwidXNlcklkIiwiZ2V0T0tScyIsImdldE9LUiIsImNyZWF0ZU9LUiIsIm9rckRhdGEiLCJ1cGRhdGVPS1IiLCJ0cmFuc2Zvcm1lZERhdGEiLCJhc3NpZ25lZF91c2VyX2lkcyIsImFzc2lnbmVkX3VzZXJzIiwibWFwIiwidXNlciIsInVzZXJfaWQiLCJwcmltYXJ5X3VzZXJfaWQiLCJmaW5kIiwiaXNfcHJpbWFyeSIsImJ1c2luZXNzX3VuaXRfaWRzIiwiYnVzaW5lc3NfdW5pdHMiLCJlbmRwb2ludCIsIm9yaWdpbmFsIiwidHJhbnNmb3JtZWQiLCJkZWxldGVPS1IiLCJnZXRDaGlsZE9LUnMiLCJwYXJlbnRPa3JJZCIsImdldE9LUkFzc2lnbmVkVXNlcnMiLCJhZGRVc2VyVG9PS1IiLCJ1c2VyRGF0YSIsInJlbW92ZVVzZXJGcm9tT0tSIiwic2V0UHJpbWFyeVVzZXJGb3JPS1IiLCJnZXRUYXNrcyIsImdldFRhc2siLCJ0YXNrSWQiLCJjcmVhdGVUYXNrIiwidGFza0RhdGEiLCJ1cGRhdGVUYXNrIiwiZGVsZXRlVGFzayIsImdldE9LUlRhc2tzIiwiZ2V0VXNlck9LUnMiLCJnZXRVc2VyVGFza3MiLCJnZXRUYXNrQ2hhbGxlbmdlcyIsImdldFRhc2tDaGFsbGVuZ2UiLCJjaGFsbGVuZ2VJZCIsImNyZWF0ZVRhc2tDaGFsbGVuZ2UiLCJjaGFsbGVuZ2VEYXRhIiwidXBkYXRlVGFza0NoYWxsZW5nZSIsImRlbGV0ZVRhc2tDaGFsbGVuZ2UiLCJnZXRUYXNrQ2hhbGxlbmdlc0J5VGFzayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/api.js\n"));

/***/ })

});